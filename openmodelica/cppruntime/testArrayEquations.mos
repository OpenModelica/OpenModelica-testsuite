// name:     testArrayEquations
// keywords: array equations, for loops
// status: correct
// teardown_command: rm -f *ArrayEquationsTest*

setCommandLineOptions("--std=3.3"); getErrorString();
setCommandLineOptions("-d=newInst,-nfScalarize,dumpSimCode"); getErrorString();
setCommandLineOptions("--postOptModules-=collapseArrayExpressions"); getErrorString();
setCommandLineOptions("--simCodeTarget=Cpp"); getErrorString();

loadString("
model ArrayEquationsTest
  function myfor
    input Real[:] u;
    input Real[size(u, 1)] previous_x;
    input Boolean isFirstTick;
    output Real[size(u, 1)] x;
  algorithm
    for i in 1:size(u,1) loop
      x[i] := if isFirstTick then previous_x[i] else previous_x[i] + u[i];
    end for;
  end myfor;

  parameter Integer n = 10;
  input Real[n] u(start = 1:n);
  Real[n] x1(each start = 1);
  Real[n] x2(each start = 2);
  Real[n] x3(each start = 3);
  output Real y1, y2, y3;
equation
  when Clock(0.1) then
    // for eqation
    for i in 1:n loop
      x1[i] = if firstTick(x1[i]) then previous(x1[i]) else previous(x1[i]) + u[i];
    end for;
    // function with for loop
    x2 = myfor(u, previous(x2), firstTick());
    // array equation
    x3 = if firstTick(x3) then previous(x3) else previous(x3) + u;
  end when;
  y1 = sum(x1);
  y2 = sum(x2);
  y3 = sum(x3);
end ArrayEquationsTest;
"); getErrorString();

simulate(ArrayEquationsTest); getErrorString();

val(y1, 1.0);
val(y2, 1.0);
val(y3, 1.0);

// Result:
// true
// ""
// true
// ""
// true
// ""
// true
// ""
// true
// ""
//
//
// *********************
// * SimCode Equations *
// *********************
//
//
// allEquations: 
// ========================================
//
// ========================================
//
//
//
// odeEquations (0 systems): 
// ========================================
// ========================================
//
//
//
// algebraicEquations (0 systems): 
// ========================================
// ========================================
//
//
// clockPartitions (1 systems):
//
// BaseClock:
// ========================================
// Clock(RCONST 0.1
// )========================================
//
// SubPartition Vars:
// ========================================
// index: -1: x1 (no alias)  initial: 	no arrCref index:() [10]  (PREVIOUS)
// index: -1: x2 (no alias)  initial: 	no arrCref index:() [10]  (PREVIOUS)
// index: -1: x3 (no alias)  initial: 	no arrCref index:() [10]  (PREVIOUS)
// index: -1: y1 (no alias)  initial: 	no arrCref index:() []  
// index: -1: y2 (no alias)  initial: 	no arrCref index:() []  
// index: -1: y3 (no alias)  initial: 	no arrCref index:() []  
// partition equations:
// ========================================
// 18: $CLKPRE.x1=x1 [Real[10] ]
// 17: $CLKPRE.x2=x2 [Real[10] ]
// 16: $CLKPRE.x3=x3 [Real[10] ]
// 10 FOR-LOOP:  for i in (1:n) loop
// x1[i]=if firstTick() then previous(x1[i]) else previous(x1[i]) + u[i][Real ]
// end for;
// 11: y1=sum(x1) [Real ]
// 12: x2=ArrayEquationsTest.myfor(u, previous(x2), firstTick()) [Real[10] ]
// 13: y2=sum(x2) [Real ]
// 14: x3=if firstTick() then previous(x3) else previous(x3) + u [Real[10] ]
// 15: y3=sum(x3) [Real ]removedEquations equations:
// ========================================
// SubClock:
// factor(1/1) shift(0/1) Hold Events: false
//
// ========================================
//
//
//
// initialEquations: (9)
// ========================================
// 1: x1=1.0 [Real ]
// 2: $CLKPRE.x1=x1 [Real[10] ]
// 3: x2=2.0 [Real ]
// 4: $CLKPRE.x2=x2 [Real[10] ]
// 5: x3=3.0 [Real ]
// 6: $CLKPRE.x3=x3 [Real[10] ]
// 7: y1=0.0 [Real ]
// 8: y2=0.0 [Real ]
// 9: y3=0.0 [Real ]
// ========================================
//
//
//
// initialEquations_lambda0: (0)
// ========================================
//
// removedInitialEquations: 
// ========================================
//
// startValueEquations: 
// ========================================
//
// nominalValueEquations: 
// ========================================
//
// minValueEquations: 
// ========================================
//
// maxValueEquations: 
// ========================================
//
// parameterEquations: 
// ========================================
//
// removedEquations: 
// ========================================
//
// algorithmAndEquationAsserts: 
// ========================================
//
// equationsForZeroCrossings: 
// ========================================
//
// jacobianEquations: 
// ========================================
//
// jacobianMatrices: 
// ========================================
// 	Jacobian idx: 0
// 	
// 	Jacobian idx: 1
// 	
// 	Jacobian idx: 2
// 	
// 	Jacobian idx: 3
// 	
//
// modelInfo: 
// ========================================
// algVars (73)
// ----------------------
// index: 0: $CLKPRE.x1 (no alias)  initial: x1	no arrCref index:(1) [10] 
// index: 1: $CLKPRE.x2 (no alias)  initial: x2	no arrCref index:(11) [10] 
// index: 2: $CLKPRE.x3 (no alias)  initial: x3	no arrCref index:(21) [10] 
// index: 3: u (no alias)  initial: 1.0:10.0	no arrCref index:(31) [10] 
// index: 4: x1 (no alias)  initial: 	no arrCref index:(41) [10] 
// index: 5: x2 (no alias)  initial: 	no arrCref index:(51) [10] 
// index: 6: x3 (no alias)  initial: 	no arrCref index:(61) [10] 
// index: 7: y1 (no alias)  initial: 	no arrCref index:(71) [] 
// index: 8: y2 (no alias)  initial: 	no arrCref index:(72) [] 
// index: 9: y3 (no alias)  initial: 	no arrCref index:(73) [] 
// intParamVars
// ----------------------
// index: 0: n (no alias)  initial: 10	no arrCref index:(74) [] 
// functions:
// -----------
//
// Function: ArrayEquationsTest.myfor
// 	outVars: x (Real, )  , 
// 	functionArguments: u (array(Real)[:], )  , previous_x (array(Real)[size(u, 1)], )  , isFirstTick (Boolean, )  , 
// 	variableDeclarations: x (Real, )  , 
// record SimulationResult
//     resultFile = "ArrayEquationsTest_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'ArrayEquationsTest', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = ""
// end SimulationResult;
// "[BackEnd/BackendDAETransform.mo:0:0-0:0:writable] Error: Internal error function strongComponentsScalar failed (sorting strong components)
// [BackEnd/BackendDAEUtil.mo:0:0-0:0:writable] Error: Internal error Transformation module sort components failed
// Warning: The optimization module detectJacobianSparsePattern failed. This module will be skipped and the transformation process continued.
// "
// 560.0
// 570.0
// 580.0
// endResult
