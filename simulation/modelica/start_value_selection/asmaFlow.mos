// name:     asmaFlow.mos [BUG: #2429]
// keywords: remove simple equation bug testing
// status:   correct
// teardown_command: rm -rf asmaFlow_* asmaFlow asmaFlow.exe


setCommandLineOptions({"+d=dumprepl,dumpindxdae"}); getErrorString();

loadModel(Modelica); getErrorString();
loadFile("asmaFlow.mo"); getErrorString();
simulate(asmaFlow); getErrorString();
val(aimc.flange.tau, 0);
val(aimc.inertiaRotor.flange_b.tau, 0);



// Result:
// {true}
// ""
// true
// ""
// true
// ""
//
// Unreplaceable Crefs: (0)
// ========================================
//
//
// Replacements: (321)
// ========================================
// const.y -> const.k
// torque.tau -> const.k
// torque.flange.tau -> -const.k
// aimc.flange.phi -> speedSensor.flange.phi
// torque.flange.phi -> speedSensor.flange.phi
// aimc.strayLoad.flange.phi -> speedSensor.flange.phi
// aimc.inertiaRotor.flange_b.phi -> speedSensor.flange.phi
// aimc.inertiaRotor.phi -> speedSensor.flange.phi
// aimc.inertiaRotor.flange_a.phi -> speedSensor.flange.phi
// aimc.airGapS.flange.phi -> speedSensor.flange.phi
// aimc.friction.flange.phi -> speedSensor.flange.phi
// ground.p.v -> 0.0
// star.pin_n.v -> 0.0
// star.plug_p.pin[3].v -> 0.0
// sinevoltage1.plug_p.pin[3].v -> 0.0
// sinevoltage1.sineVoltage[3].p.v -> 0.0
// star.plug_p.pin[2].v -> 0.0
// sinevoltage1.plug_p.pin[2].v -> 0.0
// sinevoltage1.sineVoltage[2].p.v -> 0.0
// star.plug_p.pin[1].v -> 0.0
// sinevoltage1.plug_p.pin[1].v -> 0.0
// sinevoltage1.sineVoltage[1].p.v -> 0.0
// terminalBox.plug_sp.pin[3].v -> -sinevoltage1.v[3]
// terminalBox.plugSupply.pin[3].v -> -sinevoltage1.v[3]
// sinevoltage1.plug_n.pin[3].v -> -sinevoltage1.v[3]
// sinevoltage1.sineVoltage[3].n.v -> -sinevoltage1.v[3]
// aimc.strayLoad.plug_p.pin[3].v -> -sinevoltage1.v[3]
// terminalBox.plug_sp.pin[2].v -> -sinevoltage1.v[2]
// terminalBox.plugSupply.pin[2].v -> -sinevoltage1.v[2]
// sinevoltage1.plug_n.pin[2].v -> -sinevoltage1.v[2]
// sinevoltage1.sineVoltage[2].n.v -> -sinevoltage1.v[2]
// aimc.strayLoad.plug_p.pin[2].v -> -sinevoltage1.v[2]
// terminalBox.plug_sp.pin[1].v -> -sinevoltage1.v[1]
// terminalBox.plugSupply.pin[1].v -> -sinevoltage1.v[1]
// sinevoltage1.plug_n.pin[1].v -> -sinevoltage1.v[1]
// sinevoltage1.sineVoltage[1].n.v -> -sinevoltage1.v[1]
// aimc.strayLoad.plug_p.pin[1].v -> -sinevoltage1.v[1]
// terminalBox.plug_sn.pin[3].v -> aimc.plug_sn.pin[3].v
// terminalBox.star.plug_p.pin[3].v -> aimc.plug_sn.pin[3].v
// terminalBox.star.pin_n.v -> aimc.plug_sn.pin[3].v
// terminalBox.starpoint.v -> aimc.plug_sn.pin[3].v
// terminalBox.star.plug_p.pin[2].v -> aimc.plug_sn.pin[3].v
// terminalBox.plug_sn.pin[2].v -> aimc.plug_sn.pin[3].v
// aimc.plug_sn.pin[2].v -> aimc.plug_sn.pin[3].v
// aimc.spacePhasorS.plug_n.pin[2].v -> aimc.plug_sn.pin[3].v
// terminalBox.star.plug_p.pin[1].v -> aimc.plug_sn.pin[3].v
// terminalBox.plug_sn.pin[1].v -> aimc.plug_sn.pin[3].v
// aimc.plug_sn.pin[1].v -> aimc.plug_sn.pin[3].v
// aimc.spacePhasorS.plug_n.pin[1].v -> aimc.plug_sn.pin[3].v
// aimc.spacePhasorS.plug_n.pin[3].v -> aimc.plug_sn.pin[3].v
// sinevoltage1.plug_p.pin[1].i -> sinevoltage1.i[1]
// sinevoltage1.sineVoltage[1].p.i -> sinevoltage1.i[1]
// sinevoltage1.sineVoltage[1].i -> sinevoltage1.i[1]
// sinevoltage1.sineVoltage[1].n.i -> -sinevoltage1.i[1]
// sinevoltage1.plug_n.pin[1].i -> -sinevoltage1.i[1]
// terminalBox.plugSupply.pin[1].i -> sinevoltage1.i[1]
// terminalBox.plug_sp.pin[1].i -> -sinevoltage1.i[1]
// aimc.plug_sp.pin[1].i -> sinevoltage1.i[1]
// aimc.strayLoad.plug_p.pin[1].i -> sinevoltage1.i[1]
// aimc.strayLoad.i[1] -> sinevoltage1.i[1]
// aimc.strayLoad.plug_n.pin[1].i -> -sinevoltage1.i[1]
// aimc.rs.plug_p.pin[1].i -> sinevoltage1.i[1]
// aimc.rs.resistor[1].p.i -> sinevoltage1.i[1]
// aimc.rs.resistor[1].i -> sinevoltage1.i[1]
// aimc.rs.resistor[1].n.i -> -sinevoltage1.i[1]
// aimc.rs.plug_n.pin[1].i -> -sinevoltage1.i[1]
// aimc.spacePhasorS.plug_p.pin[1].i -> sinevoltage1.i[1]
// aimc.spacePhasorS.plug_n.pin[1].i -> -sinevoltage1.i[1]
// aimc.plug_sn.pin[1].i -> -sinevoltage1.i[1]
// terminalBox.plug_sn.pin[1].i -> sinevoltage1.i[1]
// terminalBox.star.plug_p.pin[1].i -> sinevoltage1.i[1]
// aimc.rs.i[1] -> sinevoltage1.i[1]
// aimc.is[1] -> sinevoltage1.i[1]
// star.plug_p.pin[1].i -> -sinevoltage1.i[1]
// sinevoltage1.plug_p.pin[2].i -> sinevoltage1.i[2]
// sinevoltage1.sineVoltage[2].p.i -> sinevoltage1.i[2]
// sinevoltage1.sineVoltage[2].i -> sinevoltage1.i[2]
// sinevoltage1.sineVoltage[2].n.i -> -sinevoltage1.i[2]
// sinevoltage1.plug_n.pin[2].i -> -sinevoltage1.i[2]
// terminalBox.plugSupply.pin[2].i -> sinevoltage1.i[2]
// terminalBox.plug_sp.pin[2].i -> -sinevoltage1.i[2]
// aimc.plug_sp.pin[2].i -> sinevoltage1.i[2]
// aimc.strayLoad.plug_p.pin[2].i -> sinevoltage1.i[2]
// aimc.strayLoad.i[2] -> sinevoltage1.i[2]
// aimc.strayLoad.plug_n.pin[2].i -> -sinevoltage1.i[2]
// aimc.rs.plug_p.pin[2].i -> sinevoltage1.i[2]
// aimc.rs.resistor[2].p.i -> sinevoltage1.i[2]
// aimc.rs.resistor[2].i -> sinevoltage1.i[2]
// aimc.rs.resistor[2].n.i -> -sinevoltage1.i[2]
// aimc.rs.plug_n.pin[2].i -> -sinevoltage1.i[2]
// aimc.spacePhasorS.plug_p.pin[2].i -> sinevoltage1.i[2]
// aimc.spacePhasorS.plug_n.pin[2].i -> -sinevoltage1.i[2]
// aimc.plug_sn.pin[2].i -> -sinevoltage1.i[2]
// terminalBox.plug_sn.pin[2].i -> sinevoltage1.i[2]
// terminalBox.star.plug_p.pin[2].i -> sinevoltage1.i[2]
// aimc.rs.i[2] -> sinevoltage1.i[2]
// aimc.is[2] -> sinevoltage1.i[2]
// star.plug_p.pin[2].i -> -sinevoltage1.i[2]
// sinevoltage1.plug_p.pin[3].i -> sinevoltage1.i[3]
// sinevoltage1.sineVoltage[3].p.i -> sinevoltage1.i[3]
// sinevoltage1.sineVoltage[3].i -> sinevoltage1.i[3]
// sinevoltage1.sineVoltage[3].n.i -> -sinevoltage1.i[3]
// sinevoltage1.plug_n.pin[3].i -> -sinevoltage1.i[3]
// terminalBox.plugSupply.pin[3].i -> sinevoltage1.i[3]
// terminalBox.plug_sp.pin[3].i -> -sinevoltage1.i[3]
// aimc.plug_sp.pin[3].i -> sinevoltage1.i[3]
// aimc.strayLoad.plug_p.pin[3].i -> sinevoltage1.i[3]
// aimc.strayLoad.i[3] -> sinevoltage1.i[3]
// aimc.strayLoad.plug_n.pin[3].i -> -sinevoltage1.i[3]
// aimc.rs.plug_p.pin[3].i -> sinevoltage1.i[3]
// aimc.rs.resistor[3].p.i -> sinevoltage1.i[3]
// aimc.rs.resistor[3].i -> sinevoltage1.i[3]
// aimc.rs.resistor[3].n.i -> -sinevoltage1.i[3]
// aimc.rs.plug_n.pin[3].i -> -sinevoltage1.i[3]
// aimc.spacePhasorS.plug_p.pin[3].i -> sinevoltage1.i[3]
// aimc.spacePhasorS.plug_n.pin[3].i -> -sinevoltage1.i[3]
// aimc.plug_sn.pin[3].i -> -sinevoltage1.i[3]
// terminalBox.plug_sn.pin[3].i -> sinevoltage1.i[3]
// terminalBox.star.plug_p.pin[3].i -> sinevoltage1.i[3]
// aimc.rs.i[3] -> sinevoltage1.i[3]
// aimc.is[3] -> sinevoltage1.i[3]
// star.plug_p.pin[3].i -> -sinevoltage1.i[3]
// star.pin_n.i -> -ground.p.i
// aimc.statorCore.spacePhasor.v_[2] -> aimc.lssigma.spacePhasor_a.v_[2]
// aimc.spacePhasorS.spacePhasor.v_[2] -> aimc.lssigma.spacePhasor_a.v_[2]
// aimc.statorCore.spacePhasor.v_[1] -> aimc.lssigma.spacePhasor_a.v_[1]
// aimc.spacePhasorS.spacePhasor.v_[1] -> aimc.lssigma.spacePhasor_a.v_[1]
// aimc.spacePhasorS.ground.v -> 0.0
// aimc.lszero.n.v -> 0.0
// aimc.spacePhasorS.zero.v -> aimc.lszero.v
// aimc.spacePhasorS.plug_p.pin[3].v -> aimc.rs.plug_n.pin[3].v
// aimc.rs.resistor[3].n.v -> aimc.rs.plug_n.pin[3].v
// aimc.spacePhasorS.plug_p.pin[2].v -> aimc.rs.plug_n.pin[2].v
// aimc.rs.resistor[2].n.v -> aimc.rs.plug_n.pin[2].v
// aimc.spacePhasorS.plug_p.pin[1].v -> aimc.rs.plug_n.pin[1].v
// aimc.rs.resistor[1].n.v -> aimc.rs.plug_n.pin[1].v
// aimc.strayLoad.plug_n.pin[3].v -> -sinevoltage1.v[3]
// aimc.rs.resistor[3].p.v -> -sinevoltage1.v[3]
// aimc.strayLoad.plug_n.pin[2].v -> -sinevoltage1.v[2]
// aimc.rs.resistor[2].p.v -> -sinevoltage1.v[2]
// aimc.strayLoad.plug_n.pin[1].v -> -sinevoltage1.v[1]
// aimc.rs.resistor[1].p.v -> -sinevoltage1.v[1]
// aimc.thermalAmbient.constTs.y -> 293.15
// aimc.thermalAmbient.temperatureStatorWinding.T -> 293.15
// aimc.thermalAmbient.temperatureStatorWinding.port.T -> 293.15
// aimc.thermalAmbient.thermalCollectorStator.port_b.T -> 293.15
// aimc.thermalAmbient.thermalCollectorStator.port_a[3].T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].T -> 293.15
// aimc.internalThermalPort.heatPortStatorWinding[3].T -> 293.15
// aimc.rs.heatPort[3].T -> 293.15
// aimc.rs.resistor[3].heatPort.T -> 293.15
// aimc.rs.resistor[3].T_heatPort -> 293.15
// aimc.thermalAmbient.thermalCollectorStator.port_a[2].T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].T -> 293.15
// aimc.internalThermalPort.heatPortStatorWinding[2].T -> 293.15
// aimc.rs.heatPort[2].T -> 293.15
// aimc.rs.resistor[2].heatPort.T -> 293.15
// aimc.rs.resistor[2].T_heatPort -> 293.15
// aimc.thermalAmbient.thermalCollectorStator.port_a[1].T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].T -> 293.15
// aimc.internalThermalPort.heatPortStatorWinding[1].T -> 293.15
// aimc.rs.heatPort[1].T -> 293.15
// aimc.rs.resistor[1].heatPort.T -> 293.15
// aimc.rs.resistor[1].T_heatPort -> 293.15
// aimc.fixed.flange.phi -> aimc.fixed.phi0
// aimc.airGapS.support.phi -> aimc.fixed.phi0
// aimc.strayLoad.support.phi -> aimc.fixed.phi0
// aimc.internalSupport.phi -> aimc.fixed.phi0
// aimc.inertiaStator.flange_a.phi -> aimc.fixed.phi0
// aimc.inertiaStator.phi -> aimc.fixed.phi0
// aimc.inertiaStator.flange_b.phi -> aimc.fixed.phi0
// aimc.friction.support.phi -> aimc.fixed.phi0
// aimc.thermalAmbient.constTr.y -> 293.15
// aimc.thermalAmbient.temperatureRotorWinding.T -> 293.15
// aimc.thermalAmbient.temperatureRotorWinding.port.T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortRotorWinding.T -> 293.15
// aimc.internalThermalPort.heatPortRotorWinding.T -> 293.15
// aimc.squirrelCageR.heatPort.T -> 293.15
// aimc.squirrelCageR.T_heatPort -> 293.15
// aimc.lssigma.spacePhasor_b.v_[2] -> aimc.airGapS.spacePhasor_s.v_[2]
// aimc.lssigma.spacePhasor_b.v_[1] -> aimc.airGapS.spacePhasor_s.v_[1]
// aimc.squirrelCageR.spacePhasor_r.v_[2] -> aimc.airGapS.spacePhasor_r.v_[2]
// aimc.squirrelCageR.spacePhasor_r.v_[1] -> aimc.airGapS.spacePhasor_r.v_[1]
// aimc.inertiaStator.flange_b.tau -> 0.0
// aimc.airGapS.i_rr[2] -> aimc.idq_rr[2]
// aimc.airGapS.spacePhasor_r.i_[2] -> aimc.idq_rr[2]
// aimc.squirrelCageR.spacePhasor_r.i_[2] -> -aimc.idq_rr[2]
// aimc.ir[2] -> aimc.idq_rr[2]
// aimc.airGapS.i_rr[1] -> aimc.idq_rr[1]
// aimc.airGapS.spacePhasor_r.i_[1] -> aimc.idq_rr[1]
// aimc.squirrelCageR.spacePhasor_r.i_[1] -> -aimc.idq_rr[1]
// aimc.ir[1] -> aimc.idq_rr[1]
// aimc.lssigma.spacePhasor_a.i_[2] -> aimc.lssigma.i_[2]
// aimc.lssigma.spacePhasor_b.i_[2] -> -aimc.lssigma.i_[2]
// aimc.airGapS.spacePhasor_s.i_[2] -> aimc.lssigma.i_[2]
// aimc.airGapS.i_ss[2] -> aimc.lssigma.i_[2]
// aimc.idq_ss[2] -> aimc.lssigma.i_[2]
// aimc.lssigma.spacePhasor_a.i_[1] -> aimc.lssigma.i_[1]
// aimc.lssigma.spacePhasor_b.i_[1] -> -aimc.lssigma.i_[1]
// aimc.airGapS.spacePhasor_s.i_[1] -> aimc.lssigma.i_[1]
// aimc.airGapS.i_ss[1] -> aimc.lssigma.i_[1]
// aimc.idq_ss[1] -> aimc.lssigma.i_[1]
// aimc.thermalAmbient.temperatureFriction.port.Q_flow -> aimc.powerBalance.lossPowerFriction
// aimc.thermalAmbient.thermalPort.heatPortFriction.Q_flow -> aimc.powerBalance.lossPowerFriction
// aimc.thermalAmbient.temperatureStrayLoad.port.Q_flow -> aimc.strayLoad.lossPower
// aimc.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow -> aimc.strayLoad.lossPower
// aimc.internalThermalPort.heatPortRotorCore.Q_flow -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow -> 0.0
// aimc.thermalAmbient.temperatureRotorCore.port.Q_flow -> 0.0
// aimc.thermalAmbient.Q_flowRotorCore -> 0.0
// aimc.thermalAmbient.temperatureStatorCore.port.Q_flow -> aimc.statorCore.lossPower
// aimc.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow -> aimc.statorCore.lossPower
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow -> aimc.rs.resistor[1].LossPower
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow -> aimc.rs.resistor[2].LossPower
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow -> aimc.rs.resistor[3].LossPower
// aimc.thermalAmbient.temperatureRotorWinding.port.Q_flow -> aimc.thermalAmbient.Q_flowRotorWinding
// aimc.thermalAmbient.thermalPort.heatPortRotorWinding.Q_flow -> aimc.thermalAmbient.Q_flowRotorWinding
// aimc.thermalAmbient.temperatureStatorWinding.port.Q_flow -> aimc.thermalAmbient.Q_flowStatorWinding
// aimc.thermalAmbient.thermalCollectorStator.port_b.Q_flow -> -aimc.thermalAmbient.Q_flowStatorWinding
// aimc.inertiaRotor.flange_a.tau -> aimc.tauElectrical
// aimc.airGapS.flange.tau -> -aimc.tauElectrical
// aimc.airGapS.tauElectrical -> aimc.tauElectrical
// aimc.airGapS.support.tau -> aimc.tauElectrical
// aimc.rs.resistor[1].heatPort.Q_flow -> -aimc.rs.resistor[1].LossPower
// aimc.rs.heatPort[1].Q_flow -> -aimc.rs.resistor[1].LossPower
// aimc.rs.resistor[2].heatPort.Q_flow -> -aimc.rs.resistor[2].LossPower
// aimc.rs.heatPort[2].Q_flow -> -aimc.rs.resistor[2].LossPower
// aimc.rs.resistor[3].heatPort.Q_flow -> -aimc.rs.resistor[3].LossPower
// aimc.rs.heatPort[3].Q_flow -> -aimc.rs.resistor[3].LossPower
// aimc.internalThermalPort.heatPortStatorWinding[1].Q_flow -> 0.0
// aimc.internalThermalPort.heatPortStatorWinding[2].Q_flow -> 0.0
// aimc.internalThermalPort.heatPortStatorWinding[3].Q_flow -> 0.0
// aimc.internalThermalPort.heatPortRotorWinding.Q_flow -> 0.0
// aimc.internalThermalPort.heatPortFriction.Q_flow -> 0.0
// aimc.internalThermalPort.heatPortStrayLoad.Q_flow -> 0.0
// aimc.internalThermalPort.heatPortStatorCore.Q_flow -> 0.0
// aimc.spacePhasorS.zero.i -> aimc.i_0_s
// aimc.lszero.p.i -> -aimc.i_0_s
// aimc.lszero.i -> -aimc.i_0_s
// aimc.lszero.n.i -> aimc.i_0_s
// aimc.spacePhasorS.ground.i -> -aimc.i_0_s
// aimc.internalSupport.tau -> 0.0
// terminalBox.starpoint.i -> 0.0
// terminalBox.star.pin_n.i -> 0.0
// sinevoltage1.sineVoltage[3].signalSource.y -> sinevoltage1.v[3]
// sinevoltage1.sineVoltage[2].signalSource.y -> sinevoltage1.v[2]
// sinevoltage1.sineVoltage[1].signalSource.y -> sinevoltage1.v[1]
// speedSensor.flange.tau -> 0.0
// aimc.squirrelCageR.heatPort.Q_flow -> -aimc.thermalAmbient.Q_flowRotorWinding
// aimc.powerBalance.lossPowerRotorWinding -> aimc.thermalAmbient.Q_flowRotorWinding
// aimc.airGapS.RotationMatrix[1,1] -> aimc.airGapS.RotationMatrix[2,2]
// aimc.airGapS.RotationMatrix[1,2] -> -aimc.airGapS.RotationMatrix[2,1]
// aimc.strayLoad.tau -> 0.0
// aimc.strayLoad.support.tau -> 0.0
// aimc.strayLoad.flange.tau -> -0.0
// aimc.strayLoad.v[3] -> 0.0
// aimc.strayLoad.v[2] -> 0.0
// aimc.strayLoad.v[1] -> 0.0
// aimc.strayLoad.heatPort.Q_flow -> -0.0
// aimc.powerBalance.lossPowerStrayLoad -> 0.0
// aimc.statorCore.spacePhasor.i_[2] -> 0.0
// aimc.statorCore.spacePhasor.i_[1] -> 0.0
// aimc.statorCore.heatPort.Q_flow -> -0.0
// aimc.powerBalance.lossPowerStatorCore -> 0.0
// aimc.airGapS.i_rs[2] -> aimc.idq_rs[2]
// aimc.airGapS.i_rs[1] -> aimc.idq_rs[1]
// aimc.airGapS.i_sr[2] -> aimc.idq_sr[2]
// aimc.airGapS.i_sr[1] -> aimc.idq_sr[1]
// aimc.friction.lossPower -> 0.0
// aimc.friction.heatPort.Q_flow -> -0.0
// aimc.powerBalance.lossPowerRotorCore -> 0.0
// aimc.friction.tau -> 0.0
// aimc.friction.support.tau -> 0.0
// aimc.friction.flange.tau -> -0.0
// aimc.flange.tau -> -(-const.k)
// speedSensor.w -> aimc.inertiaRotor.w
// aimc.inertiaStator.w -> 0.0
// aimc.powerBalance.lossPowerFriction -> 0.0
// aimc.thermalAmbient.Q_flowFriction -> 0.0
// aimc.lszero.p.v -> aimc.lszero.v
// aimc.statorCore.lossPower -> 0.0
// aimc.thermalAmbient.Q_flowStatorCore -> 0.0
// aimc.strayLoad.lossPower -> 0.0
// aimc.thermalAmbient.Q_flowStrayLoad -> 0.0
// aimc.plug_sp.pin[1].v -> -sinevoltage1.v[1]
// aimc.rs.plug_p.pin[1].v -> -sinevoltage1.v[1]
// sinevoltage1.sineVoltage[1].v -> sinevoltage1.v[1]
// aimc.plug_sp.pin[2].v -> -sinevoltage1.v[2]
// aimc.rs.plug_p.pin[2].v -> -sinevoltage1.v[2]
// sinevoltage1.sineVoltage[2].v -> sinevoltage1.v[2]
// aimc.plug_sp.pin[3].v -> -sinevoltage1.v[3]
// aimc.rs.plug_p.pin[3].v -> -sinevoltage1.v[3]
// sinevoltage1.sineVoltage[3].v -> sinevoltage1.v[3]
// aimc.tauShaft -> -const.k
// aimc.inertiaRotor.flange_b.tau -> const.k
// aimc.spacePhasorS.spacePhasor.i_[1] -> -aimc.lssigma.i_[1]
// aimc.spacePhasorS.spacePhasor.i_[2] -> -aimc.lssigma.i_[2]
// aimc.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow -> aimc.rs.resistor[3].LossPower
// aimc.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow -> aimc.rs.resistor[2].LossPower
// aimc.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow -> aimc.rs.resistor[1].LossPower
// aimc.squirrelCageR.LossPower -> aimc.thermalAmbient.Q_flowRotorWinding
// aimc.powerBalance.powerInertiaStator -> 0.0
// aimc.inertiaStator.a -> 0.0
// aimc.thermalAmbient.temperatureStrayLoad.port.T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortStrayLoad.T -> 293.15
// aimc.internalThermalPort.heatPortStrayLoad.T -> 293.15
// aimc.strayLoad.heatPort.T -> 293.15
// aimc.thermalAmbient.temperatureStatorCore.port.T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortStatorCore.T -> 293.15
// aimc.internalThermalPort.heatPortStatorCore.T -> 293.15
// aimc.statorCore.heatPort.T -> 293.15
// aimc.thermalAmbient.temperatureRotorCore.port.T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortRotorCore.T -> 293.15
// aimc.internalThermalPort.heatPortRotorCore.T -> 293.15
// aimc.thermalAmbient.temperatureFriction.port.T -> 293.15
// aimc.thermalAmbient.thermalPort.heatPortFriction.T -> 293.15
// aimc.friction.heatPort.T -> 293.15
// aimc.internalThermalPort.heatPortFriction.T -> 293.15
// torque.phi_support -> 0.0
// aimc.statorCore.Gc -> 0.0
// aimc.statorCore.w -> aimc.statorCoreParameters.wRef
//
// ExtendReplacements: (161)
// ========================================
// const -> 0.0
// torque -> 0.0
// torque.flange -> 0.0
// aimc -> 0.0
// aimc.flange -> 0.0
// aimc.strayLoad -> 0.0
// aimc.strayLoad.flange -> 0.0
// aimc.inertiaRotor -> 0.0
// aimc.inertiaRotor.flange_b -> 0.0
// aimc.inertiaRotor.flange_a -> 0.0
// aimc.airGapS -> 0.0
// aimc.airGapS.flange -> 0.0
// aimc.friction -> 0.0
// aimc.friction.flange -> 0.0
// ground -> 0.0
// ground.p -> 0.0
// star -> 0.0
// star.pin_n -> 0.0
// star.plug_p -> 0.0
// star.plug_p.pin -> 0.0
// sinevoltage1 -> 0.0
// sinevoltage1.plug_p -> 0.0
// sinevoltage1.plug_p.pin -> 0.0
// sinevoltage1.sineVoltage -> 0.0
// sinevoltage1.sineVoltage[3].p -> 0.0
// sinevoltage1.sineVoltage[2].p -> 0.0
// sinevoltage1.sineVoltage[1].p -> 0.0
// terminalBox -> 0.0
// terminalBox.plug_sp -> 0.0
// terminalBox.plug_sp.pin -> 0.0
// terminalBox.plugSupply -> 0.0
// terminalBox.plugSupply.pin -> 0.0
// sinevoltage1.plug_n -> 0.0
// sinevoltage1.plug_n.pin -> 0.0
// sinevoltage1.sineVoltage[3].n -> 0.0
// aimc.strayLoad.plug_p -> 0.0
// aimc.strayLoad.plug_p.pin -> 0.0
// sinevoltage1.sineVoltage[2].n -> 0.0
// sinevoltage1.sineVoltage[1].n -> 0.0
// terminalBox.plug_sn -> 0.0
// terminalBox.plug_sn.pin -> 0.0
// terminalBox.star -> 0.0
// terminalBox.star.plug_p -> 0.0
// terminalBox.star.plug_p.pin -> 0.0
// terminalBox.star.pin_n -> 0.0
// terminalBox.starpoint -> 0.0
// aimc.plug_sn -> 0.0
// aimc.plug_sn.pin -> 0.0
// aimc.spacePhasorS -> 0.0
// aimc.spacePhasorS.plug_n -> 0.0
// aimc.spacePhasorS.plug_n.pin -> 0.0
// aimc.plug_sp -> 0.0
// aimc.plug_sp.pin -> 0.0
// aimc.strayLoad.i -> 0.0
// aimc.strayLoad.plug_n -> 0.0
// aimc.strayLoad.plug_n.pin -> 0.0
// aimc.rs -> 0.0
// aimc.rs.plug_p -> 0.0
// aimc.rs.plug_p.pin -> 0.0
// aimc.rs.resistor -> 0.0
// aimc.rs.resistor[1].p -> 0.0
// aimc.rs.resistor[1].n -> 0.0
// aimc.rs.plug_n -> 0.0
// aimc.rs.plug_n.pin -> 0.0
// aimc.spacePhasorS.plug_p -> 0.0
// aimc.spacePhasorS.plug_p.pin -> 0.0
// aimc.rs.i -> 0.0
// aimc.is -> 0.0
// aimc.rs.resistor[2].p -> 0.0
// aimc.rs.resistor[2].n -> 0.0
// aimc.rs.resistor[3].p -> 0.0
// aimc.rs.resistor[3].n -> 0.0
// aimc.statorCore -> 0.0
// aimc.statorCore.spacePhasor -> 0.0
// aimc.statorCore.spacePhasor.v_ -> 0.0
// aimc.spacePhasorS.spacePhasor -> 0.0
// aimc.spacePhasorS.spacePhasor.v_ -> 0.0
// aimc.spacePhasorS.ground -> 0.0
// aimc.lszero -> 0.0
// aimc.lszero.n -> 0.0
// aimc.spacePhasorS.zero -> 0.0
// aimc.thermalAmbient -> 0.0
// aimc.thermalAmbient.constTs -> 0.0
// aimc.thermalAmbient.temperatureStatorWinding -> 0.0
// aimc.thermalAmbient.temperatureStatorWinding.port -> 0.0
// aimc.thermalAmbient.thermalCollectorStator -> 0.0
// aimc.thermalAmbient.thermalCollectorStator.port_b -> 0.0
// aimc.thermalAmbient.thermalCollectorStator.port_a -> 0.0
// aimc.thermalAmbient.thermalPort -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortStatorWinding -> 0.0
// aimc.internalThermalPort -> 0.0
// aimc.internalThermalPort.heatPortStatorWinding -> 0.0
// aimc.rs.heatPort -> 0.0
// aimc.rs.resistor[3].heatPort -> 0.0
// aimc.rs.resistor[2].heatPort -> 0.0
// aimc.rs.resistor[1].heatPort -> 0.0
// aimc.fixed -> 0.0
// aimc.fixed.flange -> 0.0
// aimc.airGapS.support -> 0.0
// aimc.strayLoad.support -> 0.0
// aimc.internalSupport -> 0.0
// aimc.inertiaStator -> 0.0
// aimc.inertiaStator.flange_a -> 0.0
// aimc.inertiaStator.flange_b -> 0.0
// aimc.friction.support -> 0.0
// aimc.thermalAmbient.constTr -> 0.0
// aimc.thermalAmbient.temperatureRotorWinding -> 0.0
// aimc.thermalAmbient.temperatureRotorWinding.port -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortRotorWinding -> 0.0
// aimc.internalThermalPort.heatPortRotorWinding -> 0.0
// aimc.squirrelCageR -> 0.0
// aimc.squirrelCageR.heatPort -> 0.0
// aimc.lssigma -> 0.0
// aimc.lssigma.spacePhasor_b -> 0.0
// aimc.lssigma.spacePhasor_b.v_ -> 0.0
// aimc.squirrelCageR.spacePhasor_r -> 0.0
// aimc.squirrelCageR.spacePhasor_r.v_ -> 0.0
// aimc.airGapS.i_rr -> 0.0
// aimc.airGapS.spacePhasor_r -> 0.0
// aimc.airGapS.spacePhasor_r.i_ -> 0.0
// aimc.squirrelCageR.spacePhasor_r.i_ -> 0.0
// aimc.ir -> 0.0
// aimc.lssigma.spacePhasor_a -> 0.0
// aimc.lssigma.spacePhasor_a.i_ -> 0.0
// aimc.lssigma.spacePhasor_b.i_ -> 0.0
// aimc.airGapS.spacePhasor_s -> 0.0
// aimc.airGapS.spacePhasor_s.i_ -> 0.0
// aimc.airGapS.i_ss -> 0.0
// aimc.idq_ss -> 0.0
// aimc.thermalAmbient.temperatureFriction -> 0.0
// aimc.thermalAmbient.temperatureFriction.port -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortFriction -> 0.0
// aimc.thermalAmbient.temperatureStrayLoad -> 0.0
// aimc.thermalAmbient.temperatureStrayLoad.port -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortStrayLoad -> 0.0
// aimc.internalThermalPort.heatPortRotorCore -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortRotorCore -> 0.0
// aimc.thermalAmbient.temperatureRotorCore -> 0.0
// aimc.thermalAmbient.temperatureRotorCore.port -> 0.0
// aimc.thermalAmbient.temperatureStatorCore -> 0.0
// aimc.thermalAmbient.temperatureStatorCore.port -> 0.0
// aimc.thermalAmbient.thermalPort.heatPortStatorCore -> 0.0
// aimc.internalThermalPort.heatPortFriction -> 0.0
// aimc.internalThermalPort.heatPortStrayLoad -> 0.0
// aimc.internalThermalPort.heatPortStatorCore -> 0.0
// aimc.lszero.p -> 0.0
// sinevoltage1.sineVoltage[3].signalSource -> 0.0
// sinevoltage1.sineVoltage[2].signalSource -> 0.0
// sinevoltage1.sineVoltage[1].signalSource -> 0.0
// speedSensor -> 0.0
// speedSensor.flange -> 0.0
// aimc.powerBalance -> 0.0
// aimc.airGapS.RotationMatrix -> 0.0
// aimc.strayLoad.v -> 0.0
// aimc.strayLoad.heatPort -> 0.0
// aimc.statorCore.spacePhasor.i_ -> 0.0
// aimc.statorCore.heatPort -> 0.0
// aimc.airGapS.i_rs -> 0.0
// aimc.airGapS.i_sr -> 0.0
// aimc.friction.heatPort -> 0.0
// aimc.spacePhasorS.spacePhasor.i_ -> 0.0
//
// DerConstReplacements: (3)
// ========================================
// aimc.inertiaRotor.phi -> speedSensor.w
// aimc.inertiaStator.phi -> 0.0
// aimc.inertiaStator.w -> 0.0
//
// Unreplaceable Crefs: (1)
// ========================================
// $res1.$pDERNLSJac0.dummyVarNLSJac0
//
// Unreplaceable Crefs: (1)
// ========================================
// $res1.$pDERNLSJac0.dummyVarNLSJac0
//
// Unreplaceable Crefs: (6)
// ========================================
// $res6.$pDERNLSJac1.dummyVarNLSJac1
// $res5.$pDERNLSJac1.dummyVarNLSJac1
// $res4.$pDERNLSJac1.dummyVarNLSJac1
// $res3.$pDERNLSJac1.dummyVarNLSJac1
// $res2.$pDERNLSJac1.dummyVarNLSJac1
// $res1.$pDERNLSJac1.dummyVarNLSJac1
//
// Unreplaceable Crefs: (6)
// ========================================
// $res6.$pDERNLSJac1.dummyVarNLSJac1
// $res5.$pDERNLSJac1.dummyVarNLSJac1
// $res4.$pDERNLSJac1.dummyVarNLSJac1
// $res3.$pDERNLSJac1.dummyVarNLSJac1
// $res2.$pDERNLSJac1.dummyVarNLSJac1
// $res1.$pDERNLSJac1.dummyVarNLSJac1
//
// Unreplaceable Crefs: (0)
// ========================================
//
//
// Replacements: (12)
// ========================================
// aimc.strayLoad.w -> aimc.inertiaRotor.w
// $DER.aimc.strayLoad.phi -> aimc.inertiaRotor.w
// aimc.friction.w -> aimc.inertiaRotor.w
// $DER.aimc.friction.phi -> aimc.inertiaRotor.w
// aimc.inertiaStator.flange_a.tau -> 0.0
// aimc.fixed.flange.tau -> -aimc.tauElectrical
// aimc.wMechanical -> aimc.inertiaRotor.w
// $DER.aimc.phiMechanical -> aimc.inertiaRotor.w
// $DER.aimc.airGapS.psi_mr[1] -> aimc.airGapS.spacePhasor_r.v_[1]
// $DER.aimc.airGapS.psi_ms[2] -> aimc.airGapS.spacePhasor_s.v_[2]
// $DER.aimc.airGapS.psi_ms[1] -> aimc.airGapS.spacePhasor_s.v_[1]
// $DER.aimc.airGapS.psi_mr[2] -> aimc.airGapS.spacePhasor_r.v_[2]
//
// ExtendReplacements: (14)
// ========================================
// aimc -> 0.0
// aimc.strayLoad -> 0.0
// $DER -> 0.0
// $DER.aimc -> 0.0
// $DER.aimc.strayLoad -> 0.0
// aimc.friction -> 0.0
// $DER.aimc.friction -> 0.0
// aimc.inertiaStator -> 0.0
// aimc.inertiaStator.flange_a -> 0.0
// aimc.fixed -> 0.0
// aimc.fixed.flange -> 0.0
// $DER.aimc.airGapS -> 0.0
// $DER.aimc.airGapS.psi_mr -> 0.0
// $DER.aimc.airGapS.psi_ms -> 0.0
//
// Unreplaceable Crefs: (1)
// ========================================
// $res1.$pDERNLSJac2.dummyVarNLSJac2
//
// Unreplaceable Crefs: (1)
// ========================================
// $res1.$pDERNLSJac2.dummyVarNLSJac2
//
// Unreplaceable Crefs: (4)
// ========================================
// $res4.$pDERNLSJac3.dummyVarNLSJac3
// $res3.$pDERNLSJac3.dummyVarNLSJac3
// $res2.$pDERNLSJac3.dummyVarNLSJac3
// $res1.$pDERNLSJac3.dummyVarNLSJac3
//
// Unreplaceable Crefs: (4)
// ========================================
// $res4.$pDERNLSJac3.dummyVarNLSJac3
// $res3.$pDERNLSJac3.dummyVarNLSJac3
// $res2.$pDERNLSJac3.dummyVarNLSJac3
// $res1.$pDERNLSJac3.dummyVarNLSJac3
//
// ########################################
// dumpindxdae
// ########################################
//
//
// unspecified partition
// ========================================
//
// Variables (1)
// ========================================
// 1: aimc.inertiaStator.flange_a.tau:VARIABLE(flow=true unit = "N.m" )  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
//
//
// Equations (1, 1)
// ========================================
// 1/1 (1): aimc.inertiaStator.flange_a.tau = 0.0   [binding]
//
//
// Simple Equations (0, 0)
// ========================================
//
//
// State Sets
// ========================================
//
//
// Matching
// ========================================
// 1 variables and equations
// var 1 is solved in eqn 1
//
//
// StrongComponents
// ========================================
// {1:1}
//
//
// unspecified partition
// ========================================
//
// Variables (99)
// ========================================
// 1: sinevoltage1.i[3]:DUMMY_STATE(unit = "A" )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 2: sinevoltage1.i[2]:DUMMY_STATE(unit = "A" )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 3: sinevoltage1.i[1]:DUMMY_STATE(unit = "A" )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 4: sinevoltage1.v[3]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 5: sinevoltage1.v[2]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 6: sinevoltage1.v[1]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 7: speedSensor.flange.phi:STATE(1,aimc.inertiaRotor.w)(flow=false unit = "rad" )  "Absolute rotation angle of flange".asmaFlow, .Modelica.Mechanics.Rotational.Sensors.SpeedSensor, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 8: ground.p.i:VARIABLE(flow=true unit = "A" )  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Analog.Basic.Ground, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real
// 9: aimc.thermalAmbient.Q_flowTotal:VARIABLE(unit = "W" final = true ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 10: aimc.thermalAmbient.Q_flowRotorWinding:VARIABLE(unit = "W" final = true )  "Heat flow rate of rotor (squirrel cage)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 11: aimc.thermalAmbient.Q_flowStatorWinding:VARIABLE(unit = "W" final = true )  "Heat flow rate of stator windings".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 12: aimc.airGapS.i_ms[2]:DUMMY_STATE(unit = "A" )  "Magnetizing current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 13: aimc.airGapS.i_ms[1]:DUMMY_STATE(unit = "A" )  "Magnetizing current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 14: aimc.airGapS.spacePhasor_r.v_[2]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 15: aimc.airGapS.spacePhasor_r.v_[1]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 16: aimc.airGapS.spacePhasor_s.v_[2]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 17: aimc.airGapS.spacePhasor_s.v_[1]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 18: aimc.airGapS.RotationMatrix[2,2]:DUMMY_STATE()  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 19: aimc.airGapS.RotationMatrix[2,1]:DUMMY_STATE()  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 20: aimc.airGapS.psi_mr[2]:DUMMY_STATE(unit = "Wb" )  "Magnetizing flux phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 21: aimc.airGapS.psi_mr[1]:DUMMY_STATE(unit = "Wb" )  "Magnetizing flux phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 22: aimc.airGapS.psi_ms[2]:DUMMY_STATE(unit = "Wb" )  "Magnetizing flux phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 23: aimc.airGapS.psi_ms[1]:DUMMY_STATE(unit = "Wb" )  "Magnetizing flux phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 24: aimc.airGapS.gamma:DUMMY_STATE(unit = "rad" )  "Rotor displacement angle".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Angle type: Real
// 25: aimc.strayLoad.iRMS:VARIABLE(unit = "A" ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Current type: Real
// 26: aimc.strayLoad.phi:DUMMY_STATE(unit = "rad" )  "Angle between shaft and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Angle type: Real
// 27: aimc.spacePhasorS.i[3]:DUMMY_STATE(unit = "A" )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 28: aimc.spacePhasorS.i[2]:DUMMY_STATE(unit = "A" )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 29: aimc.spacePhasorS.i[1]:DUMMY_STATE(unit = "A" )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 30: aimc.spacePhasorS.v[3]:VARIABLE(unit = "V" )  "Instantaneous phase voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Voltage type: Real [3]
// 31: aimc.spacePhasorS.v[2]:VARIABLE(unit = "V" )  "Instantaneous phase voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Voltage type: Real [3]
// 32: aimc.spacePhasorS.v[1]:VARIABLE(unit = "V" )  "Instantaneous phase voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Voltage type: Real [3]
// 33: aimc.lszero.v:VARIABLE(unit = "V" )  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.SIunits.Voltage type: Real
// 34: aimc.lssigma.spacePhasor_a.v_[2]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 35: aimc.lssigma.spacePhasor_a.v_[1]:VARIABLE(flow=false unit = "V" )  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 36: aimc.lssigma.i_[2]:DUMMY_STATE(unit = "A" ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Current type: Real [2]
// 37: aimc.lssigma.i_[1]:DUMMY_STATE(unit = "A" ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Current type: Real [2]
// 38: aimc.lssigma.v_[2]:VARIABLE(unit = "V" ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Voltage type: Real [2]
// 39: aimc.lssigma.v_[1]:VARIABLE(unit = "V" ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Voltage type: Real [2]
// 40: aimc.rs.resistor[3].LossPower:VARIABLE(unit = "W" )  "Loss power leaving component via HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Power type: Real [3]
// 41: aimc.rs.resistor[3].v:VARIABLE(unit = "V" )  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Voltage type: Real [3]
// 42: aimc.rs.resistor[2].LossPower:VARIABLE(unit = "W" )  "Loss power leaving component via HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Power type: Real [3]
// 43: aimc.rs.resistor[2].v:VARIABLE(unit = "V" )  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Voltage type: Real [3]
// 44: aimc.rs.resistor[1].LossPower:VARIABLE(unit = "W" )  "Loss power leaving component via HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Power type: Real [3]
// 45: aimc.rs.resistor[1].v:VARIABLE(unit = "V" )  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Voltage type: Real [3]
// 46: aimc.rs.plug_n.pin[3].v:VARIABLE(flow=false unit = "V" )  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 47: aimc.rs.plug_n.pin[2].v:VARIABLE(flow=false unit = "V" )  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 48: aimc.rs.plug_n.pin[1].v:VARIABLE(flow=false unit = "V" )  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 49: aimc.rs.v[3]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Voltage type: Real [3]
// 50: aimc.rs.v[2]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Voltage type: Real [3]
// 51: aimc.rs.v[1]:VARIABLE(unit = "V" )  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Voltage type: Real [3]
// 52: aimc.plug_sn.pin[3].v:VARIABLE(flow=false unit = "V" )  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 53: aimc.idq_rr[2]:STATE(1)(unit = "A" stateSelect=StateSelect.prefer )  "Rotor space phasor current / rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$idq_rr type: Real [2]
// 54: aimc.idq_rr[1]:STATE(1)(unit = "A" stateSelect=StateSelect.prefer )  "Rotor space phasor current / rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$idq_rr type: Real [2]
// 55: aimc.idq_rs[2]:DUMMY_STATE(unit = "A" )  "Rotor space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 56: aimc.idq_rs[1]:DUMMY_STATE(unit = "A" )  "Rotor space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 57: aimc.idq_sr[2]:STATE(1)(unit = "A" stateSelect=StateSelect.prefer )  "Stator space phasor current / rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$idq_sr type: Real [2]
// 58: aimc.idq_sr[1]:STATE(1)(unit = "A" stateSelect=StateSelect.prefer )  "Stator space phasor current / rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$idq_sr type: Real [2]
// 59: aimc.i_0_s:DUMMY_STATE(start = 0.0 unit = "A" stateSelect=StateSelect.prefer )  "Stator zero-sequence current".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$i_0_s type: Real
// 60: aimc.vs[3]:VARIABLE(unit = "V" )  "Stator instantaneous voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Voltage type: Real [3]
// 61: aimc.vs[2]:VARIABLE(unit = "V" )  "Stator instantaneous voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Voltage type: Real [3]
// 62: aimc.vs[1]:VARIABLE(unit = "V" )  "Stator instantaneous voltages".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Voltage type: Real [3]
// 63: aimc.powerBalance.lossPowerStatorWinding:VARIABLE(unit = "W" final = true )  "Stator copper losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 64: aimc.powerBalance.lossPowerTotal:VARIABLE(unit = "W" final = true )  "Total loss power".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 65: aimc.powerBalance.powerInertiaRotor:VARIABLE(unit = "W" final = true )  "Rotor inertia power".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 66: aimc.powerBalance.powerMechanical:VARIABLE(unit = "W" final = true )  "Mechanical power".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 67: aimc.powerBalance.powerStator:VARIABLE(unit = "W" final = true )  "Electrical power (stator)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 68: aimc.friction.phi:DUMMY_STATE(unit = "rad" )  "Angle between shaft and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.SIunits.Angle type: Real
// 69: aimc.inertiaRotor.a:VARIABLE(unit = "rad/s2" )  "Absolute angular acceleration of component (= der(w))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.SIunits.AngularAcceleration type: Real
// 70: aimc.inertiaRotor.w:STATE(1,aimc.inertiaRotor.a)(start = 0.0 unit = "rad/s" )  "Absolute angular velocity of component (= der(phi))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.SIunits.AngularVelocity$aimc$inertiaRotor$w type: Real
// 71: aimc.tauElectrical:VARIABLE(unit = "N.m" )  "Electromagnetic torque".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Torque type: Real
// 72: aimc.phiMechanical:DUMMY_STATE(start = 0.0 unit = "rad" )  "Mechanical angle of rotor against stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Angle$aimc$phiMechanical type: Real
// 73: $DER.aimc.airGapS.gamma:DUMMY_DER(fixed = false )  "Rotor displacement angle".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Angle type: Real
// 74: $DER.aimc.airGapS.RotationMatrix[2,1]:DUMMY_DER(fixed = false )  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 75: $DER.aimc.airGapS.RotationMatrix[2,2]:DUMMY_DER(fixed = false )  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 76: $DER.aimc.idq_rs[1]:DUMMY_DER(fixed = false )  "Rotor space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 77: $DER.aimc.idq_rs[2]:DUMMY_DER(fixed = false )  "Rotor space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 78: $DER.aimc.airGapS.i_ms[1]:DUMMY_DER(fixed = false )  "Magnetizing current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 79: $DER.aimc.airGapS.i_ms[2]:DUMMY_DER(fixed = false )  "Magnetizing current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 80: $DER.sinevoltage1.i[1]:DUMMY_DER(fixed = false )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 81: $DER.sinevoltage1.i[2]:DUMMY_DER(fixed = false )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 82: $DER.sinevoltage1.i[3]:DUMMY_DER(fixed = false )  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Current type: Real [3]
// 83: $DER.aimc.lssigma.i_[1]:DUMMY_DER(fixed = false ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Current type: Real [2]
// 84: $DER.aimc.lssigma.i_[2]:DUMMY_DER(fixed = false ) .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Current type: Real [2]
// 85: $DER.aimc.spacePhasorS.i[1]:DUMMY_DER(fixed = false )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 86: $DER.aimc.spacePhasorS.i[2]:DUMMY_DER(fixed = false )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 87: $DER.aimc.spacePhasorS.i[3]:DUMMY_DER(fixed = false )  "Instantaneous phase currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.SIunits.Current type: Real [3]
// 88: $DER.aimc.i_0_s:DUMMY_DER(fixed = false )  "Stator zero-sequence current".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current$aimc$i_0_s type: Real
// 89: aimc.strayLoad.w:VARIABLE(unit = "rad/s" fixed = false )  "Relative angular velocity of flange and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.AngularVelocity type: Real
// 90: $DER.aimc.strayLoad.phi:DUMMY_DER(fixed = false )  "Angle between shaft and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Angle type: Real
// 91: aimc.friction.w:VARIABLE(unit = "rad/s" fixed = false )  "Relative angular velocity of flange and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.SIunits.AngularVelocity type: Real
// 92: $DER.aimc.friction.phi:DUMMY_DER(fixed = false )  "Angle between shaft and support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.SIunits.Angle type: Real
// 93: aimc.fixed.flange.tau:VARIABLE(flow=true unit = "N.m" fixed = false )  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Fixed, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Torque type: Real
// 94: aimc.wMechanical:VARIABLE(start = 0.0 unit = "rad/s" fixed = false )  "Mechanical angular velocity of rotor against stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.AngularVelocity$aimc$wMechanical type: Real
// 95: $DER.aimc.phiMechanical:DUMMY_DER(fixed = false )  "Mechanical angle of rotor against stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Angle$aimc$phiMechanical type: Real
// 96: $DER.aimc.airGapS.psi_mr[1]:DUMMY_DER(fixed = false )  "Magnetizing flux phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 97: $DER.aimc.airGapS.psi_ms[2]:DUMMY_DER(fixed = false )  "Magnetizing flux phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 98: $DER.aimc.airGapS.psi_ms[1]:DUMMY_DER(fixed = false )  "Magnetizing flux phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
// 99: $DER.aimc.airGapS.psi_mr[2]:DUMMY_DER(fixed = false )  "Magnetizing flux phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.MagneticFlux type: Real [2]
//
//
// Equations (99, 99)
// ========================================
// 1/1 (1): aimc.phiMechanical = speedSensor.flange.phi - aimc.fixed.phi0   [binding]
// 2/2 (1): aimc.friction.phi = speedSensor.flange.phi - aimc.fixed.phi0   [dynamic]
// 3/3 (1): aimc.strayLoad.phi = speedSensor.flange.phi - aimc.fixed.phi0   [dynamic]
// 4/4 (1): aimc.airGapS.gamma = /*Real*/(aimc.airGapS.p) * (speedSensor.flange.phi - aimc.fixed.phi0)   [dynamic]
// 5/5 (1): aimc.airGapS.RotationMatrix[2,2] = cos(aimc.airGapS.gamma)   [dynamic]
// 6/6 (1): -aimc.airGapS.RotationMatrix[2,1] = -sin(aimc.airGapS.gamma)   [dynamic]
// 7/7 (1): aimc.lssigma.i_[1] = aimc.airGapS.RotationMatrix[2,2] * aimc.idq_sr[1] - aimc.airGapS.RotationMatrix[2,1] * aimc.idq_sr[2]   [dynamic]
// 8/8 (1): aimc.lssigma.i_[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.idq_sr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.idq_sr[2]   [dynamic]
// 9/9 (1): aimc.lssigma.i_[2] = 0.5773502691896257 * aimc.spacePhasorS.i[2] + -0.5773502691896255 * aimc.spacePhasorS.i[3]   [dynamic]
// 10/10 (1): aimc.spacePhasorS.i[3] * aimc.spacePhasorS.turnsRatio = sinevoltage1.i[3]   [dynamic]
// 11/11 (1): sinevoltage1.i[1] + sinevoltage1.i[2] + sinevoltage1.i[3] = 0.0   [dynamic]
// 12/12 (1): aimc.spacePhasorS.i[2] * aimc.spacePhasorS.turnsRatio = sinevoltage1.i[2]   [dynamic]
// 13/13 (1): aimc.lssigma.i_[1] = 0.6666666666666666 * aimc.spacePhasorS.i[1] + -0.3333333333333331 * aimc.spacePhasorS.i[2] + -0.3333333333333336 * aimc.spacePhasorS.i[3]   [dynamic]
// 14/14 (1): aimc.spacePhasorS.i[1] * aimc.spacePhasorS.turnsRatio = sinevoltage1.i[1]   [dynamic]
// 15/15 (1): -3.0 * aimc.i_0_s = aimc.spacePhasorS.i[1] + aimc.spacePhasorS.i[2] + aimc.spacePhasorS.i[3]   [dynamic]
// 16/16 (1): aimc.idq_rs[1] = aimc.airGapS.RotationMatrix[2,2] * aimc.idq_rr[1] - aimc.airGapS.RotationMatrix[2,1] * aimc.idq_rr[2]   [dynamic]
// 17/17 (1): aimc.airGapS.i_ms[1] = aimc.lssigma.i_[1] + aimc.idq_rs[1]   [dynamic]
// 18/18 (1): aimc.airGapS.psi_ms[1] = 0.06931 * aimc.airGapS.i_ms[1]   [dynamic]
// 19/19 (1): aimc.idq_rs[2] = aimc.airGapS.RotationMatrix[2,1] * aimc.idq_rr[1] + aimc.airGapS.RotationMatrix[2,2] * aimc.idq_rr[2]   [dynamic]
// 20/20 (1): aimc.airGapS.i_ms[2] = aimc.lssigma.i_[2] + aimc.idq_rs[2]   [dynamic]
// 21/21 (1): aimc.airGapS.psi_ms[2] = 0.06931 * aimc.airGapS.i_ms[2]   [dynamic]
// 22/22 (1): aimc.airGapS.psi_mr[2] = aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2] - aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[1]   [dynamic]
// 23/23 (1): aimc.airGapS.psi_mr[1] = aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2]   [dynamic]
// 24/24 (1): sinevoltage1.v[3] = sinevoltage1.sineVoltage[3].signalSource.offset + (if time < sinevoltage1.sineVoltage[3].signalSource.startTime then 0.0 else sinevoltage1.sineVoltage[3].signalSource.amplitude * sin(6.283185307179586 * sinevoltage1.sineVoltage[3].signalSource.freqHz * (time - sinevoltage1.sineVoltage[3].signalSource.startTime) + sinevoltage1.sineVoltage[3].signalSource.phase))   [dynamic]
// 25/25 (1): sinevoltage1.v[2] = sinevoltage1.sineVoltage[2].signalSource.offset + (if time < sinevoltage1.sineVoltage[2].signalSource.startTime then 0.0 else sinevoltage1.sineVoltage[2].signalSource.amplitude * sin(6.283185307179586 * sinevoltage1.sineVoltage[2].signalSource.freqHz * (time - sinevoltage1.sineVoltage[2].signalSource.startTime) + sinevoltage1.sineVoltage[2].signalSource.phase))   [dynamic]
// 26/26 (1): sinevoltage1.v[1] = sinevoltage1.sineVoltage[1].signalSource.offset + (if time < sinevoltage1.sineVoltage[1].signalSource.startTime then 0.0 else sinevoltage1.sineVoltage[1].signalSource.amplitude * sin(6.283185307179586 * sinevoltage1.sineVoltage[1].signalSource.freqHz * (time - sinevoltage1.sineVoltage[1].signalSource.startTime) + sinevoltage1.sineVoltage[1].signalSource.phase))   [dynamic]
// 27/27 (1): aimc.inertiaRotor.w = der(speedSensor.flange.phi)   [dynamic]
// 28/28 (1): (-ground.p.i) - sinevoltage1.i[3] - sinevoltage1.i[1] - sinevoltage1.i[2] = 0.0   [dynamic]
// 29/29 (1): 0.6666666666666666 * aimc.thermalAmbient.Q_flowRotorWinding = aimc.squirrelCageR.Rr_actual * (aimc.idq_rr[1] ^ 2.0 + aimc.idq_rr[2] ^ 2.0)   [dynamic]
// 30/30 (1): aimc.tauElectrical = 1.5 * /*Real*/(aimc.airGapS.p) * (aimc.lssigma.i_[2] * aimc.airGapS.psi_ms[1] - aimc.lssigma.i_[1] * aimc.airGapS.psi_ms[2])   [dynamic]
// 31/31 (1): $DER.aimc.airGapS.gamma = /*Real*/(aimc.airGapS.p) * aimc.inertiaRotor.w   [dynamic]
// 32/32 (1): $DER.aimc.airGapS.RotationMatrix[2,2] = (-sin(aimc.airGapS.gamma)) * $DER.aimc.airGapS.gamma   [dynamic]
// 33/33 (1): -$DER.aimc.airGapS.RotationMatrix[2,1] = (-cos(aimc.airGapS.gamma)) * $DER.aimc.airGapS.gamma   [dynamic]
// 34/34 (1): aimc.strayLoad.iRMS = sqrt(sinevoltage1.i[1] ^ 2.0 / 3.0 + sinevoltage1.i[2] ^ 2.0 / 3.0 + sinevoltage1.i[3] ^ 2.0 / 3.0)   [binding]
// 35/35 (1): aimc.rs.resistor[3].v = aimc.rs.resistor[3].R_actual * sinevoltage1.i[3]   [dynamic]
// 36/36 (1): aimc.rs.resistor[3].LossPower = aimc.rs.resistor[3].v * sinevoltage1.i[3]   [dynamic]
// 37/37 (1): aimc.rs.resistor[3].v = (-sinevoltage1.v[3]) - aimc.rs.plug_n.pin[3].v   [dynamic]
// 38/38 (1): aimc.rs.v[3] = (-sinevoltage1.v[3]) - aimc.rs.plug_n.pin[3].v   [dynamic]
// 39/39 (1): aimc.rs.resistor[2].v = aimc.rs.resistor[2].R_actual * sinevoltage1.i[2]   [dynamic]
// 40/40 (1): aimc.rs.resistor[2].LossPower = aimc.rs.resistor[2].v * sinevoltage1.i[2]   [dynamic]
// 41/41 (1): aimc.rs.resistor[2].v = (-sinevoltage1.v[2]) - aimc.rs.plug_n.pin[2].v   [dynamic]
// 42/42 (1): aimc.rs.v[2] = (-sinevoltage1.v[2]) - aimc.rs.plug_n.pin[2].v   [dynamic]
// 43/43 (1): aimc.rs.resistor[1].v = aimc.rs.resistor[1].R_actual * sinevoltage1.i[1]   [dynamic]
// 44/44 (1): aimc.rs.resistor[1].LossPower = aimc.rs.resistor[1].v * sinevoltage1.i[1]   [dynamic]
// 45/45 (1): aimc.rs.resistor[1].LossPower + aimc.rs.resistor[2].LossPower + aimc.rs.resistor[3].LossPower - aimc.thermalAmbient.Q_flowStatorWinding = 0.0   [dynamic]
// 46/46 (1): aimc.thermalAmbient.Q_flowTotal = aimc.thermalAmbient.Q_flowStatorWinding + aimc.thermalAmbient.Q_flowRotorWinding   [binding]
// 47/47 (1): aimc.rs.resistor[1].v = (-sinevoltage1.v[1]) - aimc.rs.plug_n.pin[1].v   [dynamic]
// 48/48 (1): aimc.rs.v[1] = (-sinevoltage1.v[1]) - aimc.rs.plug_n.pin[1].v   [dynamic]
// 49/49 (1): aimc.powerBalance.lossPowerStatorWinding = aimc.rs.resistor[1].LossPower + aimc.rs.resistor[2].LossPower + aimc.rs.resistor[3].LossPower   [binding]
// 50/50 (1): aimc.powerBalance.lossPowerTotal = aimc.powerBalance.lossPowerStatorWinding + aimc.thermalAmbient.Q_flowRotorWinding   [binding]
// 51/51 (1): aimc.inertiaRotor.J * aimc.inertiaRotor.a = aimc.tauElectrical + const.k   [dynamic]
// 52/52 (1): aimc.powerBalance.powerInertiaRotor = aimc.inertiaRotor.J * aimc.inertiaRotor.a * aimc.inertiaRotor.w   [binding]
// 53/53 (1): aimc.inertiaRotor.a = der(aimc.inertiaRotor.w)   [dynamic]
// 54/54 (1): aimc.powerBalance.powerMechanical = (-aimc.inertiaRotor.w) * const.k   [binding]
// 55/55 (1): $DER.sinevoltage1.i[1] + $DER.sinevoltage1.i[2] + $DER.sinevoltage1.i[3] = 0.0   [dynamic]
// 56/56 (1): $DER.aimc.spacePhasorS.i[2] * aimc.spacePhasorS.turnsRatio = $DER.sinevoltage1.i[2]   [dynamic]
// 57/57 (1): $DER.aimc.lssigma.i_[2] = 0.5773502691896257 * $DER.aimc.spacePhasorS.i[2] + -0.5773502691896255 * $DER.aimc.spacePhasorS.i[3]   [dynamic]
// 58/58 (1): $DER.aimc.lssigma.i_[1] = 0.6666666666666666 * $DER.aimc.spacePhasorS.i[1] + -0.3333333333333331 * $DER.aimc.spacePhasorS.i[2] + -0.3333333333333336 * $DER.aimc.spacePhasorS.i[3]   [dynamic]
// 59/59 (1): $DER.aimc.airGapS.i_ms[1] = $DER.aimc.lssigma.i_[1] + $DER.aimc.idq_rs[1]   [dynamic]
// 60/60 (1): $DER.aimc.idq_rs[1] = aimc.airGapS.RotationMatrix[2,2] * der(aimc.idq_rr[1]) + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.idq_rr[1] + (-aimc.airGapS.RotationMatrix[2,1]) * der(aimc.idq_rr[2]) - $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.idq_rr[2]   [dynamic]
// 61/61 (1): aimc.airGapS.spacePhasor_r.v_[2] = (-aimc.idq_rr[2]) * aimc.squirrelCageR.Rr_actual - der(aimc.idq_rr[2]) * aimc.squirrelCageR.Lrsigma   [dynamic]
// 62/62 (1): aimc.airGapS.spacePhasor_r.v_[2] = aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.spacePhasor_s.v_[2] + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[2] + (-aimc.airGapS.RotationMatrix[2,1]) * aimc.airGapS.spacePhasor_s.v_[1] - $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[1]   [dynamic]
// 63/63 (1): aimc.airGapS.spacePhasor_r.v_[1] = aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.spacePhasor_s.v_[1] + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.airGapS.psi_ms[1] + aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.spacePhasor_s.v_[2] + $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.airGapS.psi_ms[2]   [dynamic]
// 64/64 (1): aimc.airGapS.spacePhasor_r.v_[1] = (-aimc.idq_rr[1]) * aimc.squirrelCageR.Rr_actual - der(aimc.idq_rr[1]) * aimc.squirrelCageR.Lrsigma   [dynamic]
// 65/65 (1): $DER.aimc.idq_rs[2] = aimc.airGapS.RotationMatrix[2,1] * der(aimc.idq_rr[1]) + $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.idq_rr[1] + aimc.airGapS.RotationMatrix[2,2] * der(aimc.idq_rr[2]) + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.idq_rr[2]   [dynamic]
// 66/66 (1): $DER.aimc.airGapS.i_ms[2] = $DER.aimc.lssigma.i_[2] + $DER.aimc.idq_rs[2]   [dynamic]
// 67/67 (1): aimc.airGapS.spacePhasor_s.v_[2] = 0.06931 * $DER.aimc.airGapS.i_ms[2]   [dynamic]
// 68/68 (1): aimc.lssigma.v_[2] = aimc.lssigma.spacePhasor_a.v_[2] - aimc.airGapS.spacePhasor_s.v_[2]   [dynamic]
// 69/69 (1): aimc.lssigma.v_[2] = aimc.lssigma.L[2] * $DER.aimc.lssigma.i_[2]   [dynamic]
// 70/70 (1): aimc.airGapS.spacePhasor_s.v_[1] = 0.06931 * $DER.aimc.airGapS.i_ms[1]   [dynamic]
// 71/71 (1): aimc.lssigma.v_[1] = aimc.lssigma.spacePhasor_a.v_[1] - aimc.airGapS.spacePhasor_s.v_[1]   [dynamic]
// 72/72 (1): aimc.lssigma.spacePhasor_a.v_[1] = 0.6666666666666666 * aimc.spacePhasorS.v[1] + -0.3333333333333331 * aimc.spacePhasorS.v[2] + -0.3333333333333336 * aimc.spacePhasorS.v[3]   [dynamic]
// 73/73 (1): aimc.lssigma.spacePhasor_a.v_[2] = 0.5773502691896257 * aimc.spacePhasorS.v[2] + -0.5773502691896255 * aimc.spacePhasorS.v[3]   [dynamic]
// 74/74 (1): 3.0 * aimc.lszero.v = aimc.spacePhasorS.v[1] + aimc.spacePhasorS.v[2] + aimc.spacePhasorS.v[3]   [dynamic]
// 75/75 (1): (-aimc.lszero.L) * $DER.aimc.i_0_s = aimc.lszero.v   [dynamic]
// 76/76 (1): -3.0 * $DER.aimc.i_0_s = $DER.aimc.spacePhasorS.i[1] + $DER.aimc.spacePhasorS.i[2] + $DER.aimc.spacePhasorS.i[3]   [dynamic]
// 77/77 (1): $DER.aimc.spacePhasorS.i[1] * aimc.spacePhasorS.turnsRatio = $DER.sinevoltage1.i[1]   [dynamic]
// 78/78 (1): aimc.spacePhasorS.v[3] / aimc.spacePhasorS.turnsRatio = aimc.rs.plug_n.pin[3].v - aimc.plug_sn.pin[3].v   [dynamic]
// 79/79 (1): aimc.spacePhasorS.v[2] / aimc.spacePhasorS.turnsRatio = aimc.rs.plug_n.pin[2].v - aimc.plug_sn.pin[3].v   [dynamic]
// 80/80 (1): aimc.spacePhasorS.v[1] / aimc.spacePhasorS.turnsRatio = aimc.rs.plug_n.pin[1].v - aimc.plug_sn.pin[3].v   [dynamic]
// 81/81 (1): aimc.lssigma.v_[1] = aimc.lssigma.L[1] * $DER.aimc.lssigma.i_[1]   [dynamic]
// 82/82 (1): $DER.aimc.spacePhasorS.i[3] * aimc.spacePhasorS.turnsRatio = $DER.sinevoltage1.i[3]   [dynamic]
// 83/83 (1): aimc.vs[1] = (-sinevoltage1.v[1]) - aimc.plug_sn.pin[3].v   [dynamic]
// 84/84 (1): aimc.vs[2] = (-sinevoltage1.v[2]) - aimc.plug_sn.pin[3].v   [dynamic]
// 85/85 (1): aimc.vs[3] = (-sinevoltage1.v[3]) - aimc.plug_sn.pin[3].v   [dynamic]
// 86/86 (1): aimc.powerBalance.powerStator = Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({aimc.vs[1], aimc.vs[2], aimc.vs[3]}, {sinevoltage1.i[1], sinevoltage1.i[2], sinevoltage1.i[3]})   [binding]
// 87/87 (1): $DER.aimc.lssigma.i_[1] = aimc.airGapS.RotationMatrix[2,2] * der(aimc.idq_sr[1]) + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.idq_sr[1] + (-aimc.airGapS.RotationMatrix[2,1]) * der(aimc.idq_sr[2]) - $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.idq_sr[2]   [dynamic]
// 88/88 (1): $DER.aimc.lssigma.i_[2] = aimc.airGapS.RotationMatrix[2,1] * der(aimc.idq_sr[1]) + $DER.aimc.airGapS.RotationMatrix[2,1] * aimc.idq_sr[1] + aimc.airGapS.RotationMatrix[2,2] * der(aimc.idq_sr[2]) + $DER.aimc.airGapS.RotationMatrix[2,2] * aimc.idq_sr[2]   [dynamic]
// 89/89 (1): aimc.strayLoad.w = aimc.inertiaRotor.w   [binding]
// 90/90 (1): $DER.aimc.strayLoad.phi = aimc.inertiaRotor.w   [binding]
// 91/91 (1): aimc.friction.w = aimc.inertiaRotor.w   [binding]
// 92/92 (1): $DER.aimc.friction.phi = aimc.inertiaRotor.w   [binding]
// 93/93 (1): aimc.fixed.flange.tau = -aimc.tauElectrical   [binding]
// 94/94 (1): aimc.wMechanical = aimc.inertiaRotor.w   [binding]
// 95/95 (1): $DER.aimc.phiMechanical = aimc.inertiaRotor.w   [binding]
// 96/96 (1): $DER.aimc.airGapS.psi_mr[1] = aimc.airGapS.spacePhasor_r.v_[1]   [binding]
// 97/97 (1): $DER.aimc.airGapS.psi_ms[2] = aimc.airGapS.spacePhasor_s.v_[2]   [binding]
// 98/98 (1): $DER.aimc.airGapS.psi_ms[1] = aimc.airGapS.spacePhasor_s.v_[1]   [binding]
// 99/99 (1): $DER.aimc.airGapS.psi_mr[2] = aimc.airGapS.spacePhasor_r.v_[2]   [binding]
//
//
// Simple Equations (4, 0)
// ========================================
// 1/1 (0): algorithm
//   assert(1.0 + aimc.rs.resistor[1].alpha * (293.15 - aimc.rs.resistor[1].T_ref) >= 1e-15, "Temperature outside scope of model!");
//    [dynamic]
// 2/1 (0): algorithm
//   assert(1.0 + aimc.rs.resistor[2].alpha * (293.15 - aimc.rs.resistor[2].T_ref) >= 1e-15, "Temperature outside scope of model!");
//    [dynamic]
// 3/1 (0): algorithm
//   assert(1.0 + aimc.rs.resistor[3].alpha * (293.15 - aimc.rs.resistor[3].T_ref) >= 1e-15, "Temperature outside scope of model!");
//    [dynamic]
// 4/1 (0): algorithm
//   assert(1.0 + aimc.squirrelCageR.alpha * (293.15 - aimc.squirrelCageR.T_ref) >= 1e-15, "Temperature outside scope of model!");
//    [dynamic]
//
//
// State Sets
// ========================================
//
//
// Matching
// ========================================
// 99 variables and equations
// var 1 is solved in eqn 11
// var 2 is solved in eqn 12
// var 3 is solved in eqn 14
// var 4 is solved in eqn 24
// var 5 is solved in eqn 25
// var 6 is solved in eqn 26
// var 7 is solved in eqn 27
// var 8 is solved in eqn 28
// var 9 is solved in eqn 46
// var 10 is solved in eqn 29
// var 11 is solved in eqn 45
// var 12 is solved in eqn 20
// var 13 is solved in eqn 17
// var 14 is solved in eqn 61
// var 15 is solved in eqn 63
// var 16 is solved in eqn 67
// var 17 is solved in eqn 62
// var 18 is solved in eqn 5
// var 19 is solved in eqn 6
// var 20 is solved in eqn 22
// var 21 is solved in eqn 23
// var 22 is solved in eqn 21
// var 23 is solved in eqn 18
// var 24 is solved in eqn 4
// var 25 is solved in eqn 34
// var 26 is solved in eqn 3
// var 27 is solved in eqn 10
// var 28 is solved in eqn 9
// var 29 is solved in eqn 13
// var 30 is solved in eqn 73
// var 31 is solved in eqn 79
// var 32 is solved in eqn 80
// var 33 is solved in eqn 74
// var 34 is solved in eqn 68
// var 35 is solved in eqn 72
// var 36 is solved in eqn 8
// var 37 is solved in eqn 7
// var 38 is solved in eqn 69
// var 39 is solved in eqn 71
// var 40 is solved in eqn 36
// var 41 is solved in eqn 35
// var 42 is solved in eqn 40
// var 43 is solved in eqn 39
// var 44 is solved in eqn 44
// var 45 is solved in eqn 43
// var 46 is solved in eqn 37
// var 47 is solved in eqn 41
// var 48 is solved in eqn 47
// var 49 is solved in eqn 38
// var 50 is solved in eqn 42
// var 51 is solved in eqn 48
// var 52 is solved in eqn 78
// var 53 is solved in eqn 60
// var 54 is solved in eqn 64
// var 55 is solved in eqn 19
// var 56 is solved in eqn 16
// var 57 is solved in eqn 87
// var 58 is solved in eqn 88
// var 59 is solved in eqn 15
// var 60 is solved in eqn 85
// var 61 is solved in eqn 84
// var 62 is solved in eqn 83
// var 63 is solved in eqn 49
// var 64 is solved in eqn 50
// var 65 is solved in eqn 52
// var 66 is solved in eqn 54
// var 67 is solved in eqn 86
// var 68 is solved in eqn 2
// var 69 is solved in eqn 51
// var 70 is solved in eqn 53
// var 71 is solved in eqn 30
// var 72 is solved in eqn 1
// var 73 is solved in eqn 31
// var 74 is solved in eqn 33
// var 75 is solved in eqn 32
// var 76 is solved in eqn 59
// var 77 is solved in eqn 65
// var 78 is solved in eqn 70
// var 79 is solved in eqn 66
// var 80 is solved in eqn 77
// var 81 is solved in eqn 55
// var 82 is solved in eqn 82
// var 83 is solved in eqn 81
// var 84 is solved in eqn 57
// var 85 is solved in eqn 58
// var 86 is solved in eqn 56
// var 87 is solved in eqn 76
// var 88 is solved in eqn 75
// var 89 is solved in eqn 89
// var 90 is solved in eqn 90
// var 91 is solved in eqn 91
// var 92 is solved in eqn 92
// var 93 is solved in eqn 93
// var 94 is solved in eqn 94
// var 95 is solved in eqn 95
// var 96 is solved in eqn 96
// var 97 is solved in eqn 97
// var 98 is solved in eqn 98
// var 99 is solved in eqn 99
//
//
// StrongComponents
// ========================================
// {95:95}
// {94:94}
// {92:92}
// {91:91}
// {90:90}
// {89:89}
// {54:66}
// {31:73}
// {29:10}
// {27:7}
// {26:6}
// {25:5}
// {24:4}
// {4:24}
// {5:18}
// {6:19}
// {7:37}
// {8:36}
// {{{9:28}, {10:1}, {13:29}, {12:2}, {14:3}}
// ,{11:27}} Size: 1 linear
// {39:43}
// {41:47}
// {42:50}
// {40:42}
// {35:41}
// {37:46}
// {38:49}
// {36:40}
// {28:8}
// {34:25}
// {43:45}
// {47:48}
// {48:51}
// {44:44}
// {45:11}
// {46:9}
// {49:63}
// {50:64}
// {15:59}
// {16:56}
// {17:13}
// {18:23}
// {19:55}
// {20:12}
// {21:22}
// {30:71}
// {51:69}
// {52:65}
// {53:70}
// {93:93}
// {22:20}
// {23:21}
// {32:75}
// {33:74}
// {{{67:79}, {62:14}, {70:78}, {61:53}, {63:15}, {64:54}, {65:77}, {60:76}, {66:84}, {59:83}, {69:38}, {81:39}, {68:34}, {71:35}, {78:30}, {80:32}, {73:31}, {74:33}, {75:88}, {82:82}, {57:86}, {76:85}, {56:81}, {77:80}}
// ,{79, 72, 58, 55:87, 52, 17, 16}} Size: 4 linear
// {96:96}
// {98:98}
// {99:99}
// {83:62}
// {84:61}
// {85:60}
// {86:67}
// {97:97}
// {88, 87:57, 58} Size: 2 Jacobian Linear
// {3:26}
// {2:68}
// {1:72}
//
//
//
// BackendDAEType: simulation
//
//
// Known Variables (constants) (261)
// ========================================
// 1: aimc.statorCore.wLimit:VARIABLE(unit = "rad/s" protected = true )  = max(abs(aimc.statorCoreParameters.wRef), 0.0003141592653589793)  "Limited angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.SIunits.AngularVelocity type: Real
// 2: aimc.statorCore.Gc:VARIABLE(unit = "S" )  = 0.0  "Variable core loss conductance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.SIunits.Conductance type: Real
// 3: torque.phi_support:VARIABLE(unit = "rad" protected = true )  = 0.0  "Absolute angle of support flange".asmaFlow, .Modelica.Mechanics.Rotational.Sources.Torque, .Modelica.SIunits.Angle type: Real
// 4: aimc.thermalAmbient.temperatureFriction.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureFriction, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 5: aimc.thermalAmbient.temperatureRotorCore.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureRotorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 6: aimc.thermalAmbient.temperatureStatorCore.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStatorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 7: aimc.thermalAmbient.temperatureStrayLoad.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStrayLoad, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 8: aimc.inertiaStator.a:VARIABLE(unit = "rad/s2" )  = 0.0  "Absolute angular acceleration of component (= der(w))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.SIunits.AngularAcceleration type: Real
// 9: aimc.powerBalance.powerInertiaStator:VARIABLE(unit = "W" final = true )  = 0.0  "Stator inertia power".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 10: aimc.squirrelCageR.Rr_actual:VARIABLE(unit = "Ohm" )  = aimc.squirrelCageR.Rr * (1.0 + aimc.squirrelCageR.alpha * (293.15 - aimc.squirrelCageR.T_ref))  "Actual resistance = Rr*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Resistance type: Real
// 11: aimc.strayLoad.lossPower:VARIABLE(unit = "W" )  = 0.0  "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Power type: Real
// 12: aimc.statorCore.lossPower:VARIABLE(unit = "W" )  = 0.0  "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.SIunits.Power type: Real
// 13: aimc.rs.resistor[3].R_actual:VARIABLE(unit = "Ohm" )  = aimc.rs.resistor[3].R * (1.0 + aimc.rs.resistor[3].alpha * (293.15 - aimc.rs.resistor[3].T_ref))  "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance type: Real [3]
// 14: aimc.rs.resistor[2].R_actual:VARIABLE(unit = "Ohm" )  = aimc.rs.resistor[2].R * (1.0 + aimc.rs.resistor[2].alpha * (293.15 - aimc.rs.resistor[2].T_ref))  "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance type: Real [3]
// 15: aimc.rs.resistor[1].R_actual:VARIABLE(unit = "Ohm" )  = aimc.rs.resistor[1].R * (1.0 + aimc.rs.resistor[1].alpha * (293.15 - aimc.rs.resistor[1].T_ref))  "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance type: Real [3]
// 16: aimc.powerBalance.lossPowerFriction:VARIABLE(unit = "W" final = true )  = 0.0  "Friction losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 17: aimc.inertiaStator.w:DUMMY_STATE(unit = "rad/s" )  = 0.0  "Absolute angular velocity of component (= der(phi))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.SIunits.AngularVelocity$aimc$inertiaStator$w type: Real
// 18: aimc.friction.tau:VARIABLE(unit = "N.m" )  = 0.0  "Torque".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.SIunits.Torque type: Real
// 19: aimc.powerBalance.lossPowerRotorCore:VARIABLE(unit = "W" final = true )  = 0.0  "Rotor core losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 20: aimc.statorCore.spacePhasor.i_[1]:VARIABLE(flow=true unit = "A" )  = 0.0  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 21: aimc.statorCore.spacePhasor.i_[2]:VARIABLE(flow=true unit = "A" )  = 0.0  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 22: aimc.strayLoad.v[1]:VARIABLE(unit = "V" )  = 0.0  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Voltage type: Real [3]
// 23: aimc.strayLoad.v[2]:VARIABLE(unit = "V" )  = 0.0  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Voltage type: Real [3]
// 24: aimc.strayLoad.v[3]:VARIABLE(unit = "V" )  = 0.0  "Voltage drops between the two plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Voltage type: Real [3]
// 25: aimc.strayLoad.tau:VARIABLE(unit = "N.m" )  = 0.0  "Torque".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Torque type: Real
// 26: speedSensor.flange.tau:VARIABLE(flow=true unit = "N.m" )  = 0.0  "Cut torque in the flange".asmaFlow, .Modelica.Mechanics.Rotational.Sensors.SpeedSensor, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 27: terminalBox.starpoint.i:VARIABLE(flow=true unit = "A" )  = 0.0  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real
// 28: aimc.internalSupport.tau:VARIABLE(flow=true unit = "N.m" protected = true )  = 0.0  "Reaction torque in the support/housing".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Interfaces.Support, .Modelica.SIunits.Torque type: Real
// 29: aimc.internalThermalPort.heatPortStatorCore.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 30: aimc.internalThermalPort.heatPortStrayLoad.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 31: aimc.internalThermalPort.heatPortFriction.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 32: aimc.internalThermalPort.heatPortRotorWinding.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 33: aimc.internalThermalPort.heatPortStatorWinding[3].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 34: aimc.internalThermalPort.heatPortStatorWinding[2].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 35: aimc.internalThermalPort.heatPortStatorWinding[1].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 36: aimc.internalThermalPort.heatPortRotorCore.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = 0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 37: aimc.inertiaStator.flange_b.tau:VARIABLE(flow=true unit = "N.m" )  = 0.0  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Torque type: Real
// 38: aimc.thermalAmbient.constTr.y:VARIABLE(final = true )  = 293.15  "Connector of Real output signal".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Blocks.Sources.Constant$aimc$thermalAmbient$constTr, .Modelica.Blocks.Interfaces.RealOutput type: Real
// 39: aimc.thermalAmbient.constTs.y:VARIABLE(final = true )  = 293.15  "Connector of Real output signal".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Blocks.Sources.Constant$aimc$thermalAmbient$constTs, .Modelica.Blocks.Interfaces.RealOutput type: Real
// 40: aimc.spacePhasorS.ground.v:VARIABLE(flow=false unit = "V" )  = 0.0  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real
// 41: ground.p.v:VARIABLE(flow=false unit = "V" )  = 0.0  "Potential at the pin".asmaFlow, .Modelica.Electrical.Analog.Basic.Ground, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real
// 42: DeltaOmEl:PARAM(unit = "rad/s" )  = 25.0  "Controller Delta Omega".asmaFlow, .Modelica.SIunits.AngularVelocity type: Real
// 43: terminalBox.m:PARAM()  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Integer type: Integer
// 44: terminalBox.terminalConnection:PARAM(start = "Y" final = true )  "Choose Y=star/D=delta".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .String type: String
// 45: terminalBox.plug_sp.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Integer type: Integer
// 46: terminalBox.plug_sn.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Integer type: Integer
// 47: terminalBox.plugSupply.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Integer type: Integer
// 48: terminalBox.star.m:PARAM(min = 1 )  = terminalBox.m  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Integer type: Integer
// 49: terminalBox.star.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Integer type: Integer
// 50: aimc.m:PARAM(final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Integer type: Integer
// 51: aimc.p:PARAM(min = 1 start = 2 )  = 2  "Number of pole pairs (Integer)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Integer type: Integer
// 52: aimc.fsNominal:PARAM(start = 50.0 unit = "Hz" )  = 50.0  "Nominal frequency".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Frequency$aimc$fsNominal type: Real
// 53: aimc.TsOperational:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 )  "Operational temperature of stator resistance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Temperature$aimc$TsOperational type: Real
// 54: aimc.Rs:PARAM(start = 0.03 unit = "Ohm" )  = 0.435  "Stator resistance per phase at TRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Resistance$aimc$Rs type: Real
// 55: aimc.TsRef:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 )  "Reference temperature of stator resistance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Temperature$aimc$TsRef type: Real
// 56: aimc.alpha20s:PARAM(start = 0.0 unit = "1/K" )  "Temperature coefficient of stator resistance at 20 degC".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.LinearTemperatureCoefficient20$aimc$alpha20s type: Real
// 57: aimc.Lszero:PARAM(unit = "H" )  = aimc.Lssigma  "Stator zero sequence inductance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inductance type: Real
// 58: aimc.Lssigma:PARAM(start = 0.1017764061411688 / (aimc.fsNominal * 6.283185307179586) unit = "H" )  = 0.004  "Stator stray inductance per phase".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inductance$aimc$Lssigma type: Real
// 59: aimc.pi:CONST(unit = "rad" )  = 3.141592653589793 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Angle type: Real
// 60: aimc.Jr:PARAM(start = 0.29 unit = "kg.m2" )  = 2.0  "Rotor's moment of inertia".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inertia$aimc$Jr type: Real
// 61: aimc.useSupport:PARAM(final = true )  = false  "Enable / disable (=fixed stator) support".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Boolean type: Boolean
// 62: aimc.Js:PARAM(start = aimc.Jr unit = "kg.m2" )  "Stator's moment of inertia".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inertia$aimc$Js type: Real
// 63: aimc.useThermalPort:PARAM(final = true )  = false  "Enable / disable (=fixed temperatures) thermal port".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Boolean type: Boolean
// 64: aimc.frictionParameters.PRef:PARAM(min = 0.0 unit = "W" )  = 0.0  "Reference friction losses at wRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Modelica.SIunits.Power$aimc$frictionParameters$PRef type: Real
// 65: aimc.frictionParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = 6.283185307179586 * aimc.fsNominal / /*Real*/(aimc.p)  "Reference angular velocity that the PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Modelica.SIunits.AngularVelocity$aimc$frictionParameters$wRef type: Real
// 66: aimc.frictionParameters.power_w:PARAM(min = 1e-60 )  = 2.0  "Exponent of friction torque w.r.t. angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Real type: Real
// 67: aimc.frictionParameters.tauRef:PARAM(unit = "N.m" final = true )  = 0.0  "Reference friction torque at reference angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Modelica.SIunits.Torque type: Real
// 68: aimc.frictionParameters.linear:PARAM(final = true )  = 0.001  "Linear angular velocity range with respect to reference angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Real type: Real
// 69: aimc.frictionParameters.wLinear:PARAM(unit = "rad/s" final = true )  = 0.1570796326794897  "Linear angular velocity range".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Modelica.SIunits.AngularVelocity type: Real
// 70: aimc.frictionParameters.tauLinear:PARAM(unit = "N.m" final = true )  = 0.0  "Torque corresponding with linear angular velocity range".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.FrictionParameters$aimc$frictionParameters, .Modelica.SIunits.Torque type: Real
// 71: aimc.inertiaRotor.J:PARAM(min = 0.0 start = 1.0 unit = "kg.m2" )  = aimc.Jr  "Moment of inertia".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.SIunits.Inertia$aimc$inertiaRotor$J type: Real
// 72: aimc.inertiaRotor.stateSelect:PARAM(min = StateSelect.never max = StateSelect.always )  = StateSelect.default  "Priority to use phi and w as states".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .StateSelect type: enumeration(never, avoid, default, prefer, always)
// 73: aimc.inertiaStator.J:PARAM(min = 0.0 start = 1.0 unit = "kg.m2" )  = aimc.Js  "Moment of inertia".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.SIunits.Inertia$aimc$inertiaStator$J type: Real
// 74: aimc.inertiaStator.stateSelect:PARAM(min = StateSelect.never max = StateSelect.always )  = StateSelect.default  "Priority to use phi and w as states".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .StateSelect type: enumeration(never, avoid, default, prefer, always)
// 75: aimc.friction.useHeatPort:PARAM(final = true )  = true  "=true, if heatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Boolean type: Boolean
// 76: aimc.friction.frictionParameters.PRef:PARAM(min = 0.0 unit = "W" )  = aimc.frictionParameters.PRef  "Reference friction losses at wRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Modelica.SIunits.Power$aimc$friction$frictionParameters$PRef type: Real
// 77: aimc.friction.frictionParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = aimc.frictionParameters.wRef  "Reference angular velocity that the PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Modelica.SIunits.AngularVelocity$aimc$friction$frictionParameters$wRef type: Real
// 78: aimc.friction.frictionParameters.power_w:PARAM(min = 1e-60 )  = aimc.frictionParameters.power_w  "Exponent of friction torque w.r.t. angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Real type: Real
// 79: aimc.friction.frictionParameters.tauRef:PARAM(unit = "N.m" final = true )  = 0.0  "Reference friction torque at reference angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Modelica.SIunits.Torque type: Real
// 80: aimc.friction.frictionParameters.linear:PARAM(final = true )  = 0.001  "Linear angular velocity range with respect to reference angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Real type: Real
// 81: aimc.friction.frictionParameters.wLinear:PARAM(unit = "rad/s" final = true )  = 0.1570796326794897  "Linear angular velocity range".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Modelica.SIunits.AngularVelocity type: Real
// 82: aimc.friction.frictionParameters.tauLinear:PARAM(unit = "N.m" final = true )  = 0.0  "Torque corresponding with linear angular velocity range".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Electrical.Machines.Losses.FrictionParameters, .Modelica.SIunits.Torque type: Real
// 83: aimc.statorCoreParameters.m:PARAM()  = 3  "Number of phases (1 for DC, 3 for induction machines)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Integer type: Integer
// 84: aimc.statorCoreParameters.PRef:PARAM(min = 0.0 unit = "W" )  = 0.0  "Reference core losses at reference inner voltage VRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Modelica.SIunits.Power$aimc$statorCoreParameters$PRef type: Real
// 85: aimc.statorCoreParameters.VRef:PARAM(min = 1e-60 start = 100.0 unit = "V" )  "Reference inner RMS voltage that reference core losses PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Modelica.SIunits.Voltage$aimc$statorCoreParameters$VRef type: Real
// 86: aimc.statorCoreParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = 6.283185307179586 * aimc.fsNominal  "Reference angular velocity that reference core losses PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Modelica.SIunits.AngularVelocity$aimc$statorCoreParameters$wRef type: Real
// 87: aimc.statorCoreParameters.ratioHysteresis:PARAM(min = 0.0 max = 1.0 start = 0.775 final = true )  = 0.0  "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Real type: Real
// 88: aimc.statorCoreParameters.GcRef:PARAM(unit = "S" final = true )  = 0.0  "Reference conductance at reference frequency and voltage".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Modelica.SIunits.Conductance type: Real
// 89: aimc.statorCoreParameters.wMin:PARAM(unit = "rad/s" final = true )  = 0.0003141592653589793 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.CoreParameters$aimc$statorCoreParameters, .Modelica.SIunits.AngularVelocity type: Real
// 90: aimc.strayLoadParameters.PRef:PARAM(min = 0.0 unit = "W" )  = 0.0  "Reference stray load losses at IRef and wRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.StrayLoadParameters$aimc$strayLoadParameters, .Modelica.SIunits.Power$aimc$strayLoadParameters$PRef type: Real
// 91: aimc.strayLoadParameters.IRef:PARAM(min = 1e-60 start = 100.0 unit = "A" )  "Reference RMS current that PRef refers to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.StrayLoadParameters$aimc$strayLoadParameters, .Modelica.SIunits.Current$aimc$strayLoadParameters$IRef type: Real
// 92: aimc.strayLoadParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = 6.283185307179586 * aimc.fsNominal / /*Real*/(aimc.p)  "Reference angular velocity that PRef refers to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.StrayLoadParameters$aimc$strayLoadParameters, .Modelica.SIunits.AngularVelocity$aimc$strayLoadParameters$wRef type: Real
// 93: aimc.strayLoadParameters.power_w:PARAM(min = 1e-60 )  = 1.0  "Exponent of stray load loss torque w.r.t. angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.StrayLoadParameters$aimc$strayLoadParameters, .Real type: Real
// 94: aimc.strayLoadParameters.tauRef:PARAM(unit = "N.m" final = true )  = 0.0  "Reference stray load torque at reference angular velocity and reference current".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.StrayLoadParameters$aimc$strayLoadParameters, .Modelica.SIunits.Torque type: Real
// 95: aimc.plug_sp.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Integer type: Integer
// 96: aimc.plug_sn.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Integer type: Integer
// 97: aimc.rs.m:PARAM(min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Integer type: Integer
// 98: aimc.rs.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Integer type: Integer
// 99: aimc.rs.plug_n.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Integer type: Integer
// 100: aimc.rs.mh:PARAM(min = 1 final = true )  = 3  "Number of heatPorts=number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Integer type: Integer
// 101: aimc.rs.useHeatPort:PARAM(final = true )  = true  "=true, if all HeatPorts are enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Boolean type: Boolean
// 102: aimc.rs.T[1]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Fixed device temperatures if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 103: aimc.rs.T[2]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Fixed device temperatures if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 104: aimc.rs.T[3]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Fixed device temperatures if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 105: aimc.rs.R[1]:PARAM(start = 1.0 unit = "Ohm" )  = aimc.Rs  "Resistances R_ref at temperatures T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Resistance$aimc$rs$R type: Real [3]
// 106: aimc.rs.R[2]:PARAM(start = 1.0 unit = "Ohm" )  = aimc.Rs  "Resistances R_ref at temperatures T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Resistance$aimc$rs$R type: Real [3]
// 107: aimc.rs.R[3]:PARAM(start = 1.0 unit = "Ohm" )  = aimc.Rs  "Resistances R_ref at temperatures T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Resistance$aimc$rs$R type: Real [3]
// 108: aimc.rs.T_ref[1]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 109: aimc.rs.T_ref[2]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 110: aimc.rs.T_ref[3]:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TsRef  "Reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Temperature type: Real [3]
// 111: aimc.rs.alpha[1]:PARAM(unit = "1/K" )  = aimc.alpha20s / (1.0 + aimc.alpha20s * (-293.15 + aimc.TsRef))  "Temperature coefficients of resistances at reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 112: aimc.rs.alpha[2]:PARAM(unit = "1/K" )  = aimc.alpha20s / (1.0 + aimc.alpha20s * (-293.15 + aimc.TsRef))  "Temperature coefficients of resistances at reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 113: aimc.rs.alpha[3]:PARAM(unit = "1/K" )  = aimc.alpha20s / (1.0 + aimc.alpha20s * (-293.15 + aimc.TsRef))  "Temperature coefficients of resistances at reference temperatures".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 114: aimc.rs.resistor[1].useHeatPort:PARAM(final = true )  = true  "=true, if HeatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Boolean type: Boolean [3]
// 115: aimc.rs.resistor[1].T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T[1]  "Fixed device temperature if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 116: aimc.rs.resistor[1].R:PARAM(start = 1.0 unit = "Ohm" )  = aimc.rs.R[1]  "Resistance at temperature T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance$aimc$rs$resistor$R type: Real [3]
// 117: aimc.rs.resistor[1].T_ref:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T_ref[1]  "Reference temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 118: aimc.rs.resistor[1].alpha:PARAM(unit = "1/K" )  = aimc.rs.alpha[1]  "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 119: aimc.rs.resistor[2].useHeatPort:PARAM(final = true )  = true  "=true, if HeatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Boolean type: Boolean [3]
// 120: aimc.rs.resistor[2].T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T[2]  "Fixed device temperature if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 121: aimc.rs.resistor[2].R:PARAM(start = 1.0 unit = "Ohm" )  = aimc.rs.R[2]  "Resistance at temperature T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance$aimc$rs$resistor$R type: Real [3]
// 122: aimc.rs.resistor[2].T_ref:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T_ref[2]  "Reference temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 123: aimc.rs.resistor[2].alpha:PARAM(unit = "1/K" )  = aimc.rs.alpha[2]  "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 124: aimc.rs.resistor[3].useHeatPort:PARAM(final = true )  = true  "=true, if HeatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Boolean type: Boolean [3]
// 125: aimc.rs.resistor[3].T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T[3]  "Fixed device temperature if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 126: aimc.rs.resistor[3].R:PARAM(start = 1.0 unit = "Ohm" )  = aimc.rs.R[3]  "Resistance at temperature T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Resistance$aimc$rs$resistor$R type: Real [3]
// 127: aimc.rs.resistor[3].T_ref:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.rs.T_ref[3]  "Reference temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 128: aimc.rs.resistor[3].alpha:PARAM(unit = "1/K" )  = aimc.rs.alpha[3]  "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.LinearTemperatureCoefficient type: Real [3]
// 129: aimc.lssigma.L[1]:PARAM(unit = "H" )  = aimc.Lssigma  "Inductance of both axes".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Inductance type: Real [2]
// 130: aimc.lssigma.L[2]:PARAM(unit = "H" )  = aimc.Lssigma  "Inductance of both axes".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.SIunits.Inductance type: Real [2]
// 131: aimc.lszero.L:PARAM(start = 1.0 unit = "H" )  = aimc.Lszero  "Inductance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.SIunits.Inductance$aimc$lszero$L type: Real
// 132: aimc.statorCore.useHeatPort:PARAM(final = true )  = true  "=true, if heatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Boolean type: Boolean
// 133: aimc.statorCore.coreParameters.m:PARAM()  = aimc.statorCoreParameters.m  "Number of phases (1 for DC, 3 for induction machines)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Integer type: Integer
// 134: aimc.statorCore.coreParameters.PRef:PARAM(min = 0.0 unit = "W" )  = aimc.statorCoreParameters.PRef  "Reference core losses at reference inner voltage VRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Modelica.SIunits.Power$aimc$statorCore$coreParameters$PRef type: Real
// 135: aimc.statorCore.coreParameters.VRef:PARAM(min = 1e-60 unit = "V" )  = aimc.statorCoreParameters.VRef  "Reference inner RMS voltage that reference core losses PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Modelica.SIunits.Voltage$aimc$statorCore$coreParameters$VRef type: Real
// 136: aimc.statorCore.coreParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = aimc.statorCoreParameters.wRef  "Reference angular velocity that reference core losses PRef refer to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Modelica.SIunits.AngularVelocity$aimc$statorCore$coreParameters$wRef type: Real
// 137: aimc.statorCore.coreParameters.ratioHysteresis:PARAM(min = 0.0 max = 1.0 start = 0.775 final = true )  = 0.0  "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Real type: Real
// 138: aimc.statorCore.coreParameters.GcRef:PARAM(unit = "S" final = true )  = 0.0  "Reference conductance at reference frequency and voltage".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Modelica.SIunits.Conductance type: Real
// 139: aimc.statorCore.coreParameters.wMin:PARAM(unit = "rad/s" final = true )  = 0.0003141592653589793 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Losses.CoreParameters, .Modelica.SIunits.AngularVelocity type: Real
// 140: aimc.statorCore.m:PARAM(final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Integer type: Integer
// 141: aimc.statorCore.turnsRatio:PARAM(min = 1e-60 )  = 1.0  "Effective number of stator turns / effective number of rotor turns (if used as rotor core)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Real type: Real
// 142: aimc.spacePhasorS.m:CONST()  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Integer type: Integer
// 143: aimc.spacePhasorS.pi:CONST()  = 3.141592653589793 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real
// 144: aimc.spacePhasorS.turnsRatio:PARAM()  = 1.0  "Turns ratio".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real
// 145: aimc.spacePhasorS.TransformationMatrix[1,1]:PARAM(protected = true final = true )  = 0.6666666666666666 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 146: aimc.spacePhasorS.TransformationMatrix[1,2]:PARAM(protected = true final = true )  = -0.3333333333333331 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 147: aimc.spacePhasorS.TransformationMatrix[1,3]:PARAM(protected = true final = true )  = -0.3333333333333336 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 148: aimc.spacePhasorS.TransformationMatrix[2,1]:PARAM(protected = true final = true )  = 0.0 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 149: aimc.spacePhasorS.TransformationMatrix[2,2]:PARAM(protected = true final = true )  = 0.5773502691896257 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 150: aimc.spacePhasorS.TransformationMatrix[2,3]:PARAM(protected = true final = true )  = -0.5773502691896255 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [2,3]
// 151: aimc.spacePhasorS.InverseTransformation[1,1]:PARAM(protected = true final = true )  = 1.0 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 152: aimc.spacePhasorS.InverseTransformation[1,2]:PARAM(protected = true final = true )  = 0.0 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 153: aimc.spacePhasorS.InverseTransformation[2,1]:PARAM(protected = true final = true )  = -0.4999999999999998 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 154: aimc.spacePhasorS.InverseTransformation[2,2]:PARAM(protected = true final = true )  = 0.8660254037844387 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 155: aimc.spacePhasorS.InverseTransformation[3,1]:PARAM(protected = true final = true )  = -0.5000000000000004 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 156: aimc.spacePhasorS.InverseTransformation[3,2]:PARAM(protected = true final = true )  = -0.8660254037844384 .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Real type: Real [3,2]
// 157: aimc.spacePhasorS.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Integer type: Integer
// 158: aimc.spacePhasorS.plug_n.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Integer type: Integer
// 159: aimc.strayLoad.m:PARAM(min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Integer type: Integer
// 160: aimc.strayLoad.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Integer type: Integer
// 161: aimc.strayLoad.plug_n.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Integer type: Integer
// 162: aimc.strayLoad.useHeatPort:PARAM(final = true )  = true  "=true, if heatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Boolean type: Boolean
// 163: aimc.strayLoad.strayLoadParameters.PRef:PARAM(min = 0.0 unit = "W" )  = aimc.strayLoadParameters.PRef  "Reference stray load losses at IRef and wRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.Machines.Losses.StrayLoadParameters, .Modelica.SIunits.Power$aimc$strayLoad$strayLoadParameters$PRef type: Real
// 164: aimc.strayLoad.strayLoadParameters.IRef:PARAM(min = 1e-60 unit = "A" )  = aimc.strayLoadParameters.IRef  "Reference RMS current that PRef refers to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.Machines.Losses.StrayLoadParameters, .Modelica.SIunits.Current$aimc$strayLoad$strayLoadParameters$IRef type: Real
// 165: aimc.strayLoad.strayLoadParameters.wRef:PARAM(min = 1e-60 unit = "rad/s" )  = aimc.strayLoadParameters.wRef  "Reference angular velocity that PRef refers to".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.Machines.Losses.StrayLoadParameters, .Modelica.SIunits.AngularVelocity$aimc$strayLoad$strayLoadParameters$wRef type: Real
// 166: aimc.strayLoad.strayLoadParameters.power_w:PARAM(min = 1e-60 )  = aimc.strayLoadParameters.power_w  "Exponent of stray load loss torque w.r.t. angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.Machines.Losses.StrayLoadParameters, .Real type: Real
// 167: aimc.strayLoad.strayLoadParameters.tauRef:PARAM(unit = "N.m" final = true )  = 0.0  "Reference stray load torque at reference angular velocity and reference current".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.Machines.Losses.StrayLoadParameters, .Modelica.SIunits.Torque type: Real
// 168: aimc.internalThermalPort.m:PARAM(flow=false final = true )  = 3  "Number of stator phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Integer type: Integer
// 169: aimc.airGapS.m:PARAM(final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Integer type: Integer
// 170: aimc.airGapS.p:PARAM(min = 1 )  = aimc.p  "Number of pole pairs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Integer type: Integer
// 171: aimc.airGapS.Lm:PARAM(unit = "H" )  = aimc.Lm  "Main field inductance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Inductance type: Real
// 172: aimc.airGapS.L[1,1]:PARAM(unit = "H" protected = true final = true )  = 0.06931  "Inductance matrix".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Inductance type: Real [2,2]
// 173: aimc.airGapS.L[1,2]:PARAM(unit = "H" protected = true final = true )  = 0.0  "Inductance matrix".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Inductance type: Real [2,2]
// 174: aimc.airGapS.L[2,1]:PARAM(unit = "H" protected = true final = true )  = 0.0  "Inductance matrix".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Inductance type: Real [2,2]
// 175: aimc.airGapS.L[2,2]:PARAM(unit = "H" protected = true final = true )  = 0.06931  "Inductance matrix".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Inductance type: Real [2,2]
// 176: aimc.Lm:PARAM(start = 2.898223593858831 / (aimc.fsNominal * 6.283185307179586) unit = "H" )  = 0.06931  "Stator main field inductance per phase".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inductance$aimc$Lm type: Real
// 177: aimc.Lrsigma:PARAM(start = 0.1017764061411688 / (aimc.fsNominal * 6.283185307179586) unit = "H" )  = 0.002  "Rotor stray inductance per phase (equivalent three phase winding)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Inductance$aimc$Lrsigma type: Real
// 178: aimc.Rr:PARAM(start = 0.04 unit = "Ohm" )  = 0.4  "Rotor resistance per phase (equivalent three phase winding) at TRef".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Resistance$aimc$Rr type: Real
// 179: aimc.TrRef:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 )  "Reference temperature of rotor resistance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Temperature$aimc$TrRef type: Real
// 180: aimc.alpha20r:PARAM(start = 0.0 unit = "1/K" )  "Temperature coefficient of rotor resistance at 20 degC".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.LinearTemperatureCoefficient20$aimc$alpha20r type: Real
// 181: aimc.TrOperational:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 )  "Operational temperature of rotor resistance".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Temperature$aimc$TrOperational type: Real
// 182: aimc.squirrelCageR.useHeatPort:PARAM(final = true )  = true  "=true, if HeatPort is enabled".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Boolean type: Boolean
// 183: aimc.squirrelCageR.T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TrRef  "Fixed device temperature if useHeatPort = false".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Temperature type: Real
// 184: aimc.squirrelCageR.Lrsigma:PARAM(unit = "H" )  = aimc.Lrsigma  "Rotor stray inductance per phase translated to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Inductance type: Real
// 185: aimc.squirrelCageR.Rr:PARAM(unit = "Ohm" )  = aimc.Rr  "Rotor resistance per phase translated to stator at T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Resistance type: Real
// 186: aimc.squirrelCageR.T_ref:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.TrRef  "Reference temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Temperature type: Real
// 187: aimc.squirrelCageR.alpha:PARAM(unit = "1/K" )  = aimc.alpha20r / (1.0 + aimc.alpha20r * (-293.15 + aimc.TrRef))  "Temperature coefficient of resistance at T_ref".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.LinearTemperatureCoefficient type: Real
// 188: aimc.fixed.phi0:PARAM(unit = "rad" )  = 0.0  "Fixed offset angle of housing".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Fixed, .Modelica.SIunits.Angle type: Real
// 189: aimc.thermalAmbient.m:PARAM(final = true )  = 3  "Number of stator phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Integer type: Integer
// 190: aimc.thermalAmbient.useTemperatureInputs:PARAM(final = true )  = false  "If true, temperature inputs are used; else, temperatures are constant".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Boolean type: Boolean
// 191: aimc.thermalAmbient.TDefault:CONST(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Default temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.Temperature type: Real
// 192: aimc.thermalAmbient.Ts:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Temperature of stator windings".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.Temperature$aimc$thermalAmbient$Ts type: Real
// 193: aimc.thermalAmbient.thermalPort.m:PARAM(flow=false final = true )  = 3  "Number of stator phases".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Integer type: Integer
// 194: aimc.thermalAmbient.temperatureStatorCore.T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Fixed temperature at port".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStatorCore, .Modelica.SIunits.Temperature type: Real
// 195: aimc.thermalAmbient.temperatureRotorCore.T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Fixed temperature at port".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureRotorCore, .Modelica.SIunits.Temperature type: Real
// 196: aimc.thermalAmbient.temperatureStrayLoad.T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Fixed temperature at port".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStrayLoad, .Modelica.SIunits.Temperature type: Real
// 197: aimc.thermalAmbient.temperatureFriction.T:PARAM(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Fixed temperature at port".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureFriction, .Modelica.SIunits.Temperature type: Real
// 198: aimc.thermalAmbient.thermalCollectorStator.m:PARAM(min = 1 final = true )  = 3  "Number of collected heat flows".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Integer type: Integer
// 199: aimc.thermalAmbient.Tr:PARAM(min = 0.0 start = 293.15 unit = "K" nominal = 300.0 final = true )  = 293.15  "Temperature of rotor (squirrel cage)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.Temperature$aimc$thermalAmbient$Tr type: Real
// 200: aimc.thermalAmbient.constTs.k:PARAM(start = 1.0 final = true )  = 293.15  "Constant output value".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Blocks.Sources.Constant$aimc$thermalAmbient$constTs, .Real type: Real
// 201: aimc.thermalAmbient.constTr.k:PARAM(start = 1.0 final = true )  = 293.15  "Constant output value".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Blocks.Sources.Constant$aimc$thermalAmbient$constTr, .Real type: Real
// 202: star.m:PARAM(min = 1 )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Integer type: Integer
// 203: star.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Integer type: Integer
// 204: torque.useSupport:PARAM(final = true )  = false  "= true, if support flange enabled, otherwise implicitly grounded".asmaFlow, .Modelica.Mechanics.Rotational.Sources.Torque, .Boolean type: Boolean
// 205: const.k:PARAM(start = 1.0 )  = -15.0  "Constant output value".asmaFlow, .Modelica.Blocks.Sources.Constant$const, .Real type: Real
// 206: sinevoltage1.m:PARAM(min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Integer type: Integer
// 207: sinevoltage1.plug_p.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Integer type: Integer
// 208: sinevoltage1.plug_n.m:PARAM(flow=false min = 1 final = true )  = 3  "Number of phases".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Integer type: Integer
// 209: sinevoltage1.V[1]:PARAM(start = 1.0 unit = "V" )  = 187.794213613377  "Amplitudes of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage$sinevoltage1$V type: Real [3]
// 210: sinevoltage1.V[2]:PARAM(start = 1.0 unit = "V" )  = 187.794213613377  "Amplitudes of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage$sinevoltage1$V type: Real [3]
// 211: sinevoltage1.V[3]:PARAM(start = 1.0 unit = "V" )  = 187.794213613377  "Amplitudes of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage$sinevoltage1$V type: Real [3]
// 212: sinevoltage1.phase[1]:PARAM(unit = "rad" )  = -0.0  "Phases of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Angle type: Real [3]
// 213: sinevoltage1.phase[2]:PARAM(unit = "rad" )  = -2.094395102393195  "Phases of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Angle type: Real [3]
// 214: sinevoltage1.phase[3]:PARAM(unit = "rad" )  = -4.188790204786391  "Phases of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Angle type: Real [3]
// 215: sinevoltage1.freqHz[1]:PARAM(start = 1.0 unit = "Hz" )  = 50.0  "Frequencies of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Frequency$sinevoltage1$freqHz type: Real [3]
// 216: sinevoltage1.freqHz[2]:PARAM(start = 1.0 unit = "Hz" )  = 50.0  "Frequencies of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Frequency$sinevoltage1$freqHz type: Real [3]
// 217: sinevoltage1.freqHz[3]:PARAM(start = 1.0 unit = "Hz" )  = 50.0  "Frequencies of sine waves".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Frequency$sinevoltage1$freqHz type: Real [3]
// 218: sinevoltage1.offset[1]:PARAM(unit = "V" )  = 0.0  "Voltage offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 219: sinevoltage1.offset[2]:PARAM(unit = "V" )  = 0.0  "Voltage offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 220: sinevoltage1.offset[3]:PARAM(unit = "V" )  = 0.0  "Voltage offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Voltage type: Real [3]
// 221: sinevoltage1.startTime[1]:PARAM(unit = "s" )  = 0.0  "Time offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Time type: Real [3]
// 222: sinevoltage1.startTime[2]:PARAM(unit = "s" )  = 0.0  "Time offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Time type: Real [3]
// 223: sinevoltage1.startTime[3]:PARAM(unit = "s" )  = 0.0  "Time offsets".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.SIunits.Time type: Real [3]
// 224: sinevoltage1.sineVoltage[1].offset:PARAM(unit = "V" )  = sinevoltage1.offset[1]  "Voltage offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 225: sinevoltage1.sineVoltage[1].startTime:PARAM(unit = "s" )  = sinevoltage1.startTime[1]  "Time offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Time type: Real [3]
// 226: sinevoltage1.sineVoltage[1].signalSource.amplitude:PARAM()  = sinevoltage1.sineVoltage[1].V  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 227: sinevoltage1.sineVoltage[1].signalSource.freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.sineVoltage[1].freqHz  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$signalSource$freqHz type: Real [3]
// 228: sinevoltage1.sineVoltage[1].signalSource.phase:PARAM(unit = "rad" )  = sinevoltage1.sineVoltage[1].phase  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Angle type: Real [3]
// 229: sinevoltage1.sineVoltage[1].signalSource.offset:PARAM()  = sinevoltage1.sineVoltage[1].offset  "Offset of output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 230: sinevoltage1.sineVoltage[1].signalSource.startTime:PARAM(unit = "s" )  = sinevoltage1.sineVoltage[1].startTime  "Output = offset for time < startTime".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Time type: Real [3]
// 231: sinevoltage1.sineVoltage[1].signalSource.pi:CONST(protected = true )  = 3.141592653589793 .asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 232: sinevoltage1.sineVoltage[1].V:PARAM(start = 1.0 unit = "V" )  = sinevoltage1.V[1]  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage$sinevoltage1$sineVoltage$V type: Real [3]
// 233: sinevoltage1.sineVoltage[1].phase:PARAM(unit = "rad" )  = sinevoltage1.phase[1]  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Angle type: Real [3]
// 234: sinevoltage1.sineVoltage[1].freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.freqHz[1]  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$freqHz type: Real [3]
// 235: sinevoltage1.sineVoltage[2].offset:PARAM(unit = "V" )  = sinevoltage1.offset[2]  "Voltage offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 236: sinevoltage1.sineVoltage[2].startTime:PARAM(unit = "s" )  = sinevoltage1.startTime[2]  "Time offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Time type: Real [3]
// 237: sinevoltage1.sineVoltage[2].signalSource.amplitude:PARAM()  = sinevoltage1.sineVoltage[2].V  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 238: sinevoltage1.sineVoltage[2].signalSource.freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.sineVoltage[2].freqHz  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$signalSource$freqHz type: Real [3]
// 239: sinevoltage1.sineVoltage[2].signalSource.phase:PARAM(unit = "rad" )  = sinevoltage1.sineVoltage[2].phase  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Angle type: Real [3]
// 240: sinevoltage1.sineVoltage[2].signalSource.offset:PARAM()  = sinevoltage1.sineVoltage[2].offset  "Offset of output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 241: sinevoltage1.sineVoltage[2].signalSource.startTime:PARAM(unit = "s" )  = sinevoltage1.sineVoltage[2].startTime  "Output = offset for time < startTime".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Time type: Real [3]
// 242: sinevoltage1.sineVoltage[2].signalSource.pi:CONST(protected = true )  = 3.141592653589793 .asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 243: sinevoltage1.sineVoltage[2].V:PARAM(start = 1.0 unit = "V" )  = sinevoltage1.V[2]  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage$sinevoltage1$sineVoltage$V type: Real [3]
// 244: sinevoltage1.sineVoltage[2].phase:PARAM(unit = "rad" )  = sinevoltage1.phase[2]  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Angle type: Real [3]
// 245: sinevoltage1.sineVoltage[2].freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.freqHz[2]  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$freqHz type: Real [3]
// 246: sinevoltage1.sineVoltage[3].offset:PARAM(unit = "V" )  = sinevoltage1.offset[3]  "Voltage offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 247: sinevoltage1.sineVoltage[3].startTime:PARAM(unit = "s" )  = sinevoltage1.startTime[3]  "Time offset".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Time type: Real [3]
// 248: sinevoltage1.sineVoltage[3].signalSource.amplitude:PARAM()  = sinevoltage1.sineVoltage[3].V  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 249: sinevoltage1.sineVoltage[3].signalSource.freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.sineVoltage[3].freqHz  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$signalSource$freqHz type: Real [3]
// 250: sinevoltage1.sineVoltage[3].signalSource.phase:PARAM(unit = "rad" )  = sinevoltage1.sineVoltage[3].phase  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Angle type: Real [3]
// 251: sinevoltage1.sineVoltage[3].signalSource.offset:PARAM()  = sinevoltage1.sineVoltage[3].offset  "Offset of output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 252: sinevoltage1.sineVoltage[3].signalSource.startTime:PARAM(unit = "s" )  = sinevoltage1.sineVoltage[3].startTime  "Output = offset for time < startTime".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.SIunits.Time type: Real [3]
// 253: sinevoltage1.sineVoltage[3].signalSource.pi:CONST(protected = true )  = 3.141592653589793 .asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Real type: Real [3]
// 254: sinevoltage1.sineVoltage[3].V:PARAM(start = 1.0 unit = "V" )  = sinevoltage1.V[3]  "Amplitude of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage$sinevoltage1$sineVoltage$V type: Real [3]
// 255: sinevoltage1.sineVoltage[3].phase:PARAM(unit = "rad" )  = sinevoltage1.phase[3]  "Phase of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Angle type: Real [3]
// 256: sinevoltage1.sineVoltage[3].freqHz:PARAM(start = 1.0 unit = "Hz" )  = sinevoltage1.freqHz[3]  "Frequency of sine wave".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Frequency$sinevoltage1$sineVoltage$freqHz type: Real [3]
// 257: aimc.strayLoad.flange.tau:VARIABLE(flow=true unit = "N.m" )  = -0.0  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 258: aimc.strayLoad.heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$strayLoad$heatPort, .Modelica.SIunits.HeatFlowRate type: Real
// 259: aimc.statorCore.heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$statorCore$heatPort, .Modelica.SIunits.HeatFlowRate type: Real
// 260: aimc.friction.heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -0.0  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$friction$heatPort, .Modelica.SIunits.HeatFlowRate type: Real
// 261: aimc.friction.flange.tau:VARIABLE(flow=true unit = "N.m" )  = -0.0  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
//
//
// External Objects (0)
// ========================================
//
//
// Classes of External Objects (0)
// ========================================
//
//
// Alias Variables (280)
// ========================================
// 1: const.y:VARIABLE()  = const.k  "Connector of Real output signal".asmaFlow, .Modelica.Blocks.Sources.Constant$const, .Modelica.Blocks.Interfaces.RealOutput type: Real
// 2: torque.tau:VARIABLE(unit = "N.m" )  = const.k  "Accelerating torque acting at flange (= -flange.tau)".asmaFlow, .Modelica.Mechanics.Rotational.Sources.Torque, .Modelica.Blocks.Interfaces.RealInput$torque$tau type: Real
// 3: torque.flange.tau:VARIABLE(flow=true unit = "N.m" )  = -const.k  "Cut torque in the flange".asmaFlow, .Modelica.Mechanics.Rotational.Sources.Torque, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Torque type: Real
// 4: aimc.flange.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 5: torque.flange.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Mechanics.Rotational.Sources.Torque, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Angle type: Real
// 6: aimc.strayLoad.flange.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 7: aimc.inertiaRotor.flange_b.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Angle type: Real
// 8: aimc.inertiaRotor.phi:DUMMY_STATE(unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of component".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.SIunits.Angle$aimc$inertiaRotor$phi type: Real
// 9: aimc.inertiaRotor.flange_a.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 10: aimc.airGapS.flange.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 11: aimc.friction.flange.phi:VARIABLE(flow=false unit = "rad" )  = speedSensor.flange.phi  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 12: star.pin_n.v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real
// 13: star.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 14: sinevoltage1.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 15: sinevoltage1.sineVoltage[3].p.v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 16: star.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 17: sinevoltage1.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 18: sinevoltage1.sineVoltage[2].p.v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 19: star.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 20: sinevoltage1.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 21: sinevoltage1.sineVoltage[1].p.v:VARIABLE(flow=false unit = "V" )  = ground.p.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 22: terminalBox.plug_sp.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 23: terminalBox.plugSupply.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 24: sinevoltage1.plug_n.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 25: sinevoltage1.sineVoltage[3].n.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 26: aimc.strayLoad.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 27: terminalBox.plug_sp.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 28: terminalBox.plugSupply.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 29: sinevoltage1.plug_n.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 30: sinevoltage1.sineVoltage[2].n.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 31: aimc.strayLoad.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 32: terminalBox.plug_sp.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 33: terminalBox.plugSupply.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 34: sinevoltage1.plug_n.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 35: sinevoltage1.sineVoltage[1].n.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 36: aimc.strayLoad.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 37: terminalBox.plug_sn.pin[3].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 38: terminalBox.star.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 39: terminalBox.star.pin_n.v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real
// 40: terminalBox.starpoint.v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real
// 41: terminalBox.star.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 42: terminalBox.plug_sn.pin[2].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 43: aimc.plug_sn.pin[2].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 44: aimc.spacePhasorS.plug_n.pin[2].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 45: terminalBox.star.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 46: terminalBox.plug_sn.pin[1].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 47: aimc.plug_sn.pin[1].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 48: aimc.spacePhasorS.plug_n.pin[1].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 49: aimc.spacePhasorS.plug_n.pin[3].v:VARIABLE(flow=false unit = "V" )  = aimc.plug_sn.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 50: sinevoltage1.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 51: sinevoltage1.sineVoltage[1].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 52: sinevoltage1.sineVoltage[1].i:VARIABLE(unit = "A" )  = sinevoltage1.i[1]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Current type: Real [3]
// 53: sinevoltage1.sineVoltage[1].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 54: sinevoltage1.plug_n.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 55: terminalBox.plugSupply.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 56: terminalBox.plug_sp.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 57: aimc.plug_sp.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 58: aimc.strayLoad.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 59: aimc.strayLoad.i[1]:VARIABLE(unit = "A" )  = sinevoltage1.i[1]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Current type: Real [3]
// 60: aimc.strayLoad.plug_n.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 61: aimc.rs.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 62: aimc.rs.resistor[1].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 63: aimc.rs.resistor[1].i:VARIABLE(unit = "A" )  = sinevoltage1.i[1]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Current type: Real [3]
// 64: aimc.rs.resistor[1].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 65: aimc.rs.plug_n.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 66: aimc.spacePhasorS.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 67: aimc.spacePhasorS.plug_n.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 68: aimc.plug_sn.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 69: terminalBox.plug_sn.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 70: terminalBox.star.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 71: aimc.rs.i[1]:VARIABLE(unit = "A" )  = sinevoltage1.i[1]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Current type: Real [3]
// 72: aimc.is[1]:VARIABLE(unit = "A" )  = sinevoltage1.i[1]  "Stator instantaneous currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [3]
// 73: star.plug_p.pin[1].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[1]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 74: sinevoltage1.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 75: sinevoltage1.sineVoltage[2].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 76: sinevoltage1.sineVoltage[2].i:VARIABLE(unit = "A" )  = sinevoltage1.i[2]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Current type: Real [3]
// 77: sinevoltage1.sineVoltage[2].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 78: sinevoltage1.plug_n.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 79: terminalBox.plugSupply.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 80: terminalBox.plug_sp.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 81: aimc.plug_sp.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 82: aimc.strayLoad.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 83: aimc.strayLoad.i[2]:VARIABLE(unit = "A" )  = sinevoltage1.i[2]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Current type: Real [3]
// 84: aimc.strayLoad.plug_n.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 85: aimc.rs.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 86: aimc.rs.resistor[2].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 87: aimc.rs.resistor[2].i:VARIABLE(unit = "A" )  = sinevoltage1.i[2]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Current type: Real [3]
// 88: aimc.rs.resistor[2].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 89: aimc.rs.plug_n.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 90: aimc.spacePhasorS.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 91: aimc.spacePhasorS.plug_n.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 92: aimc.plug_sn.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 93: terminalBox.plug_sn.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 94: terminalBox.star.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 95: aimc.rs.i[2]:VARIABLE(unit = "A" )  = sinevoltage1.i[2]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Current type: Real [3]
// 96: aimc.is[2]:VARIABLE(unit = "A" )  = sinevoltage1.i[2]  "Stator instantaneous currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [3]
// 97: star.plug_p.pin[2].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[2]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 98: sinevoltage1.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$sinevoltage1$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 99: sinevoltage1.sineVoltage[3].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 100: sinevoltage1.sineVoltage[3].i:VARIABLE(unit = "A" )  = sinevoltage1.i[3]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Current type: Real [3]
// 101: sinevoltage1.sineVoltage[3].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 102: sinevoltage1.plug_n.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$sinevoltage1$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 103: terminalBox.plugSupply.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plugSupply, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 104: terminalBox.plug_sp.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 105: aimc.plug_sp.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 106: aimc.strayLoad.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$strayLoad$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 107: aimc.strayLoad.i[3]:VARIABLE(unit = "A" )  = sinevoltage1.i[3]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.SIunits.Current type: Real [3]
// 108: aimc.strayLoad.plug_n.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 109: aimc.rs.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 110: aimc.rs.resistor[3].p.i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real [3]
// 111: aimc.rs.resistor[3].i:VARIABLE(unit = "A" )  = sinevoltage1.i[3]  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Current type: Real [3]
// 112: aimc.rs.resistor[3].n.i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real [3]
// 113: aimc.rs.plug_n.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$rs$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 114: aimc.spacePhasorS.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 115: aimc.spacePhasorS.plug_n.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$spacePhasorS$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 116: aimc.plug_sn.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 117: terminalBox.plug_sn.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$terminalBox$plug_sn, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 118: terminalBox.star.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$terminalBox$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 119: aimc.rs.i[3]:VARIABLE(unit = "A" )  = sinevoltage1.i[3]  "Currents flowing into positive plugs".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.SIunits.Current type: Real [3]
// 120: aimc.is[3]:VARIABLE(unit = "A" )  = sinevoltage1.i[3]  "Stator instantaneous currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [3]
// 121: star.plug_p.pin[3].i:VARIABLE(flow=true unit = "A" )  = -sinevoltage1.i[3]  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$star$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Current type: Real [3]
// 122: star.pin_n.i:VARIABLE(flow=true unit = "A" )  = -ground.p.i  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.MultiPhase.Basic.Star, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real
// 123: aimc.statorCore.spacePhasor.v_[2]:VARIABLE(flow=false unit = "V" )  = aimc.lssigma.spacePhasor_a.v_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 124: aimc.spacePhasorS.spacePhasor.v_[2]:VARIABLE(flow=false unit = "V" )  = aimc.lssigma.spacePhasor_a.v_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 125: aimc.statorCore.spacePhasor.v_[1]:VARIABLE(flow=false unit = "V" )  = aimc.lssigma.spacePhasor_a.v_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 126: aimc.spacePhasorS.spacePhasor.v_[1]:VARIABLE(flow=false unit = "V" )  = aimc.lssigma.spacePhasor_a.v_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 127: aimc.lszero.n.v:VARIABLE(flow=false unit = "V" )  = aimc.spacePhasorS.ground.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real
// 128: aimc.spacePhasorS.zero.v:VARIABLE(flow=false unit = "V" )  = aimc.lszero.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real
// 129: aimc.spacePhasorS.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 130: aimc.rs.resistor[3].n.v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[3].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 131: aimc.spacePhasorS.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[2].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 132: aimc.rs.resistor[2].n.v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[2].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 133: aimc.spacePhasorS.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[1].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$spacePhasorS$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 134: aimc.rs.resistor[1].n.v:VARIABLE(flow=false unit = "V" )  = aimc.rs.plug_n.pin[1].v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Voltage type: Real [3]
// 135: aimc.strayLoad.plug_n.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 136: aimc.rs.resistor[3].p.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 137: aimc.strayLoad.plug_n.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 138: aimc.rs.resistor[2].p.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 139: aimc.strayLoad.plug_n.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Electrical.MultiPhase.Interfaces.NegativePlug$aimc$strayLoad$plug_n, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 140: aimc.rs.resistor[1].p.v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real [3]
// 141: aimc.thermalAmbient.temperatureStatorWinding.T:VARIABLE(unit = "K" final = true )  = aimc.thermalAmbient.constTs.y .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Blocks.Interfaces.RealInput$aimc$thermalAmbient$temperatureStatorWinding$T type: Real
// 142: aimc.thermalAmbient.temperatureStatorWinding.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 143: aimc.thermalAmbient.thermalCollectorStator.port_b.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 144: aimc.thermalAmbient.thermalCollectorStator.port_a[3].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 145: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 146: aimc.internalThermalPort.heatPortStatorWinding[3].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 147: aimc.rs.heatPort[3].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 148: aimc.rs.resistor[3].heatPort.T:VARIABLE(flow=false min = 0.0 start = aimc.rs.resistor[3].T unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.Temperature$aimc$rs$resistor$heatPort$T type: Real [3]
// 149: aimc.rs.resistor[3].T_heatPort:VARIABLE(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Temperature of HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 150: aimc.thermalAmbient.thermalCollectorStator.port_a[2].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 151: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 152: aimc.internalThermalPort.heatPortStatorWinding[2].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 153: aimc.rs.heatPort[2].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 154: aimc.rs.resistor[2].heatPort.T:VARIABLE(flow=false min = 0.0 start = aimc.rs.resistor[2].T unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.Temperature$aimc$rs$resistor$heatPort$T type: Real [3]
// 155: aimc.rs.resistor[2].T_heatPort:VARIABLE(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Temperature of HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 156: aimc.thermalAmbient.thermalCollectorStator.port_a[1].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 157: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 158: aimc.internalThermalPort.heatPortStatorWinding[1].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 159: aimc.rs.heatPort[1].T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real [3]
// 160: aimc.rs.resistor[1].heatPort.T:VARIABLE(flow=false min = 0.0 start = aimc.rs.resistor[1].T unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.Temperature$aimc$rs$resistor$heatPort$T type: Real [3]
// 161: aimc.rs.resistor[1].T_heatPort:VARIABLE(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTs.y  "Temperature of HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.SIunits.Temperature type: Real [3]
// 162: aimc.fixed.flange.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Fixed, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Angle type: Real
// 163: aimc.airGapS.support.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 164: aimc.strayLoad.support.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 165: aimc.internalSupport.phi:VARIABLE(flow=false unit = "rad" protected = true )  = aimc.fixed.phi0  "Absolute rotation angle of the support/housing".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Interfaces.Support, .Modelica.SIunits.Angle type: Real
// 166: aimc.inertiaStator.flange_a.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 167: aimc.inertiaStator.phi:DUMMY_STATE(unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of component".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.SIunits.Angle$aimc$inertiaStator$phi type: Real
// 168: aimc.inertiaStator.flange_b.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaStator, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Angle type: Real
// 169: aimc.friction.support.phi:VARIABLE(flow=false unit = "rad" )  = aimc.fixed.phi0  "Absolute rotation angle of flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Angle type: Real
// 170: aimc.thermalAmbient.temperatureRotorWinding.T:VARIABLE(unit = "K" final = true )  = aimc.thermalAmbient.constTr.y .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Blocks.Interfaces.RealInput$aimc$thermalAmbient$temperatureRotorWinding$T type: Real
// 171: aimc.thermalAmbient.temperatureRotorWinding.port.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTr.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.Temperature type: Real
// 172: aimc.thermalAmbient.thermalPort.heatPortRotorWinding.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTr.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 173: aimc.internalThermalPort.heatPortRotorWinding.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.constTr.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 174: aimc.squirrelCageR.heatPort.T:VARIABLE(flow=false min = 0.0 start = aimc.squirrelCageR.T unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTr.y  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$squirrelCageR$heatPort, .Modelica.SIunits.Temperature$aimc$squirrelCageR$heatPort$T type: Real
// 175: aimc.squirrelCageR.T_heatPort:VARIABLE(min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.constTr.y  "Temperature of HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Temperature type: Real
// 176: aimc.lssigma.spacePhasor_b.v_[2]:VARIABLE(flow=false unit = "V" )  = aimc.airGapS.spacePhasor_s.v_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 177: aimc.lssigma.spacePhasor_b.v_[1]:VARIABLE(flow=false unit = "V" )  = aimc.airGapS.spacePhasor_s.v_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 178: aimc.squirrelCageR.spacePhasor_r.v_[2]:VARIABLE(flow=false unit = "V" )  = aimc.airGapS.spacePhasor_r.v_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 179: aimc.squirrelCageR.spacePhasor_r.v_[1]:VARIABLE(flow=false unit = "V" )  = aimc.airGapS.spacePhasor_r.v_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Voltage type: Real [2]
// 180: aimc.airGapS.i_rr[2]:VARIABLE(unit = "A" )  = aimc.idq_rr[2]  "Rotor current space phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 181: aimc.airGapS.spacePhasor_r.i_[2]:VARIABLE(flow=true unit = "A" )  = aimc.idq_rr[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 182: aimc.squirrelCageR.spacePhasor_r.i_[2]:DUMMY_STATE(flow=true unit = "A" )  = -aimc.idq_rr[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 183: aimc.ir[2]:VARIABLE(unit = "A" )  = aimc.idq_rr[2]  "Rotor cage currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 184: aimc.airGapS.i_rr[1]:VARIABLE(unit = "A" )  = aimc.idq_rr[1]  "Rotor current space phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 185: aimc.airGapS.spacePhasor_r.i_[1]:VARIABLE(flow=true unit = "A" )  = aimc.idq_rr[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 186: aimc.squirrelCageR.spacePhasor_r.i_[1]:DUMMY_STATE(flow=true unit = "A" )  = -aimc.idq_rr[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 187: aimc.ir[1]:VARIABLE(unit = "A" )  = aimc.idq_rr[1]  "Rotor cage currents".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 188: aimc.lssigma.spacePhasor_a.i_[2]:VARIABLE(flow=true unit = "A" )  = aimc.lssigma.i_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 189: aimc.lssigma.spacePhasor_b.i_[2]:VARIABLE(flow=true unit = "A" )  = -aimc.lssigma.i_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 190: aimc.airGapS.spacePhasor_s.i_[2]:VARIABLE(flow=true unit = "A" )  = aimc.lssigma.i_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 191: aimc.airGapS.i_ss[2]:VARIABLE(unit = "A" )  = aimc.lssigma.i_[2]  "Stator current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 192: aimc.idq_ss[2]:VARIABLE(unit = "A" )  = aimc.lssigma.i_[2]  "Stator space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 193: aimc.lssigma.spacePhasor_a.i_[1]:VARIABLE(flow=true unit = "A" )  = aimc.lssigma.i_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 194: aimc.lssigma.spacePhasor_b.i_[1]:VARIABLE(flow=true unit = "A" )  = -aimc.lssigma.i_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.Inductor$aimc$lssigma, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 195: aimc.airGapS.spacePhasor_s.i_[1]:VARIABLE(flow=true unit = "A" )  = aimc.lssigma.i_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 196: aimc.airGapS.i_ss[1]:VARIABLE(unit = "A" )  = aimc.lssigma.i_[1]  "Stator current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 197: aimc.idq_ss[1]:VARIABLE(unit = "A" )  = aimc.lssigma.i_[1]  "Stator space phasor current / stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Current type: Real [2]
// 198: aimc.thermalAmbient.temperatureFriction.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.powerBalance.lossPowerFriction  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureFriction, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 199: aimc.thermalAmbient.thermalPort.heatPortFriction.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.powerBalance.lossPowerFriction  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 200: aimc.thermalAmbient.temperatureStrayLoad.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.strayLoad.lossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStrayLoad, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 201: aimc.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.strayLoad.lossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 202: aimc.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.internalThermalPort.heatPortRotorCore.Q_flow  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 203: aimc.thermalAmbient.temperatureRotorCore.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.internalThermalPort.heatPortRotorCore.Q_flow  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureRotorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 204: aimc.thermalAmbient.Q_flowRotorCore:VARIABLE(unit = "W" final = true )  = aimc.internalThermalPort.heatPortRotorCore.Q_flow  "Heat flow rate of stator core losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 205: aimc.thermalAmbient.temperatureStatorCore.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.statorCore.lossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.FixedTemperature$aimc$thermalAmbient$temperatureStatorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 206: aimc.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.statorCore.lossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 207: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[1].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 208: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[2].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 209: aimc.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[3].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 210: aimc.thermalAmbient.temperatureRotorWinding.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.thermalAmbient.Q_flowRotorWinding  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 211: aimc.thermalAmbient.thermalPort.heatPortRotorWinding.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.thermalAmbient.Q_flowRotorWinding  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real
// 212: aimc.thermalAmbient.temperatureStatorWinding.port.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.thermalAmbient.Q_flowStatorWinding  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 213: aimc.thermalAmbient.thermalCollectorStator.port_b.Q_flow:VARIABLE(flow=true unit = "W" final = true )  = -aimc.thermalAmbient.Q_flowStatorWinding  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b, .Modelica.SIunits.HeatFlowRate type: Real
// 214: aimc.inertiaRotor.flange_a.tau:VARIABLE(flow=true unit = "N.m" )  = aimc.tauElectrical  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 215: aimc.airGapS.flange.tau:VARIABLE(flow=true unit = "N.m" )  = -aimc.tauElectrical  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 216: aimc.airGapS.tauElectrical:VARIABLE(unit = "N.m" )  = aimc.tauElectrical .asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Torque type: Real
// 217: aimc.airGapS.support.tau:VARIABLE(flow=true unit = "N.m" )  = aimc.tauElectrical  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 218: aimc.rs.resistor[1].heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[1].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 219: aimc.rs.heatPort[1].Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[1].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 220: aimc.rs.resistor[2].heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[2].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 221: aimc.rs.heatPort[2].Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[2].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 222: aimc.rs.resistor[3].heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[3].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.Analog.Basic.Resistor$aimc$rs$resistor, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$rs$resistor$heatPort, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 223: aimc.rs.heatPort[3].Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.rs.resistor[3].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 224: aimc.spacePhasorS.zero.i:VARIABLE(flow=true unit = "A" )  = aimc.i_0_s  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real
// 225: aimc.lszero.p.i:VARIABLE(flow=true unit = "A" )  = -aimc.i_0_s  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Current type: Real
// 226: aimc.lszero.i:DUMMY_STATE(start = 0.0 unit = "A" )  = -aimc.i_0_s  "Current flowing from pin p to pin n".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.SIunits.Current$aimc$lszero$i type: Real
// 227: aimc.lszero.n.i:VARIABLE(flow=true unit = "A" )  = aimc.i_0_s  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real
// 228: aimc.spacePhasorS.ground.i:VARIABLE(flow=true unit = "A" )  = -aimc.i_0_s  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real
// 229: terminalBox.star.pin_n.i:VARIABLE(flow=true unit = "A" )  = terminalBox.starpoint.i  "Current flowing into the pin".asmaFlow, .Modelica.Electrical.Machines.Utilities.TerminalBox, .Modelica.Electrical.MultiPhase.Basic.Star$terminalBox$star, .Modelica.Electrical.Analog.Interfaces.NegativePin, .Modelica.SIunits.Current type: Real
// 230: sinevoltage1.sineVoltage[3].signalSource.y:VARIABLE()  = sinevoltage1.v[3]  "Connector of Real output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.Blocks.Interfaces.RealOutput type: Real [3]
// 231: sinevoltage1.sineVoltage[2].signalSource.y:VARIABLE()  = sinevoltage1.v[2]  "Connector of Real output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.Blocks.Interfaces.RealOutput type: Real [3]
// 232: sinevoltage1.sineVoltage[1].signalSource.y:VARIABLE()  = sinevoltage1.v[1]  "Connector of Real output signal".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.Blocks.Sources.Sine$sinevoltage1$sineVoltage$signalSource, .Modelica.Blocks.Interfaces.RealOutput type: Real [3]
// 233: aimc.squirrelCageR.heatPort.Q_flow:VARIABLE(flow=true unit = "W" )  = -aimc.thermalAmbient.Q_flowRotorWinding  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$squirrelCageR$heatPort, .Modelica.SIunits.HeatFlowRate type: Real
// 234: aimc.powerBalance.lossPowerRotorWinding:VARIABLE(unit = "W" final = true )  = aimc.thermalAmbient.Q_flowRotorWinding  "Rotor copper losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 235: aimc.airGapS.RotationMatrix[1,1]:VARIABLE()  = aimc.airGapS.RotationMatrix[2,2]  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 236: aimc.airGapS.RotationMatrix[1,2]:VARIABLE()  = -aimc.airGapS.RotationMatrix[2,1]  "Matrix of rotation from rotor to stator".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Real type: Real [2,2]
// 237: aimc.strayLoad.support.tau:VARIABLE(flow=true unit = "N.m" )  = aimc.strayLoad.tau  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 238: aimc.powerBalance.lossPowerStrayLoad:VARIABLE(unit = "W" final = true )  = aimc.strayLoad.lossPower  "Stray load losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 239: aimc.powerBalance.lossPowerStatorCore:VARIABLE(unit = "W" final = true )  = aimc.statorCore.lossPower  "Stator core losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.PowerBalanceAIMC$aimc$powerBalance, .Modelica.SIunits.Power type: Real
// 240: aimc.airGapS.i_rs[2]:VARIABLE(unit = "A" )  = aimc.idq_rs[2]  "Rotor current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 241: aimc.airGapS.i_rs[1]:VARIABLE(unit = "A" )  = aimc.idq_rs[1]  "Rotor current space phasor with respect to the stator fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 242: aimc.airGapS.i_sr[2]:VARIABLE(unit = "A" )  = aimc.idq_sr[2]  "Stator current space phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 243: aimc.airGapS.i_sr[1]:VARIABLE(unit = "A" )  = aimc.idq_sr[1]  "Stator current space phasor with respect to the rotor fixed frame".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.AirGapS$aimc$airGapS, .Modelica.SIunits.Current type: Real [2]
// 244: aimc.friction.lossPower:VARIABLE(unit = "W" )  = aimc.powerBalance.lossPowerFriction  "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.SIunits.Power type: Real
// 245: aimc.friction.support.tau:VARIABLE(flow=true unit = "N.m" )  = aimc.friction.tau  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 246: aimc.flange.tau:VARIABLE(flow=true unit = "N.m" )  = -(-const.k)  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Interfaces.Flange_a, .Modelica.SIunits.Torque type: Real
// 247: speedSensor.w:VARIABLE(unit = "rad/s" )  = aimc.inertiaRotor.w  "Absolute angular velocity of flange as output signal".asmaFlow, .Modelica.Mechanics.Rotational.Sensors.SpeedSensor, .Modelica.Blocks.Interfaces.RealOutput$speedSensor$w type: Real
// 248: aimc.thermalAmbient.Q_flowFriction:VARIABLE(unit = "W" final = true )  = aimc.powerBalance.lossPowerFriction  "Heat flow rate of friction losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 249: aimc.lszero.p.v:VARIABLE(flow=false unit = "V" )  = aimc.lszero.v  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Analog.Basic.Inductor$aimc$lszero, .Modelica.Electrical.Analog.Interfaces.PositivePin, .Modelica.SIunits.Voltage type: Real
// 250: aimc.thermalAmbient.Q_flowStatorCore:VARIABLE(unit = "W" final = true )  = aimc.statorCore.lossPower  "Heat flow rate of stator core losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 251: aimc.thermalAmbient.Q_flowStrayLoad:VARIABLE(unit = "W" final = true )  = aimc.strayLoad.lossPower  "Heat flow rate of stray load losses".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.SIunits.HeatFlowRate type: Real
// 252: aimc.plug_sp.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 253: aimc.rs.plug_p.pin[1].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[1]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 254: sinevoltage1.sineVoltage[1].v:VARIABLE(unit = "V" )  = sinevoltage1.v[1]  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 255: aimc.plug_sp.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 256: aimc.rs.plug_p.pin[2].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[2]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 257: sinevoltage1.sineVoltage[2].v:VARIABLE(unit = "V" )  = sinevoltage1.v[2]  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 258: aimc.plug_sp.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$plug_sp, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 259: aimc.rs.plug_p.pin[3].v:VARIABLE(flow=false unit = "V" )  = -sinevoltage1.v[3]  "Potential at the pin".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.MultiPhase.Basic.Resistor$aimc$rs, .Modelica.Electrical.MultiPhase.Interfaces.PositivePlug$aimc$rs$plug_p, .Modelica.Electrical.Analog.Interfaces.Pin, .Modelica.SIunits.Voltage type: Real [3]
// 260: sinevoltage1.sineVoltage[3].v:VARIABLE(unit = "V" )  = sinevoltage1.v[3]  "Voltage drop between the two pins (= p.v - n.v)".asmaFlow, .Modelica.Electrical.MultiPhase.Sources.SineVoltage$sinevoltage1, .Modelica.Electrical.Analog.Sources.SineVoltage$sinevoltage1$sineVoltage, .Modelica.SIunits.Voltage type: Real [3]
// 261: aimc.tauShaft:VARIABLE(unit = "N.m" )  = -const.k  "Shaft torque".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.SIunits.Torque type: Real
// 262: aimc.inertiaRotor.flange_b.tau:VARIABLE(flow=true unit = "N.m" )  = const.k  "Cut torque in the flange".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Mechanics.Rotational.Components.Inertia$aimc$inertiaRotor, .Modelica.Mechanics.Rotational.Interfaces.Flange_b, .Modelica.SIunits.Torque type: Real
// 263: aimc.spacePhasorS.spacePhasor.i_[1]:VARIABLE(flow=true unit = "A" )  = -aimc.lssigma.i_[1]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 264: aimc.spacePhasorS.spacePhasor.i_[2]:VARIABLE(flow=true unit = "A" )  = -aimc.lssigma.i_[2]  "1=real, 2=imaginary part".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor$aimc$spacePhasorS, .Modelica.Electrical.Machines.Interfaces.SpacePhasor, .Modelica.SIunits.Current type: Real [2]
// 265: aimc.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[3].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 266: aimc.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[2].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 267: aimc.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow:VARIABLE(flow=true unit = "W" final = true )  = aimc.rs.resistor[1].LossPower  "Heat flow rate (positive if flowing from outside into the component)".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Thermal.HeatTransfer.Components.ThermalCollector$aimc$thermalAmbient$thermalCollectorStator, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.HeatFlowRate type: Real [3]
// 268: aimc.squirrelCageR.LossPower:VARIABLE(unit = "W" )  = aimc.thermalAmbient.Q_flowRotorWinding  "Loss power leaving component via HeatPort".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage$aimc$squirrelCageR, .Modelica.SIunits.Power type: Real
// 269: aimc.thermalAmbient.thermalPort.heatPortStrayLoad.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureStrayLoad.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 270: aimc.internalThermalPort.heatPortStrayLoad.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureStrayLoad.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 271: aimc.strayLoad.heatPort.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.temperatureStrayLoad.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.StrayLoad$aimc$strayLoad, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$strayLoad$heatPort, .Modelica.SIunits.Temperature type: Real
// 272: aimc.thermalAmbient.thermalPort.heatPortStatorCore.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureStatorCore.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 273: aimc.internalThermalPort.heatPortStatorCore.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureStatorCore.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 274: aimc.statorCore.heatPort.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.temperatureStatorCore.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$statorCore$heatPort, .Modelica.SIunits.Temperature type: Real
// 275: aimc.thermalAmbient.thermalPort.heatPortRotorCore.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureRotorCore.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 276: aimc.internalThermalPort.heatPortRotorCore.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureRotorCore.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 277: aimc.thermalAmbient.thermalPort.heatPortFriction.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureFriction.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Thermal.AsynchronousInductionMachines.ThermalAmbientAIMC$aimc$thermalAmbient, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$thermalAmbient$thermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 278: aimc.friction.heatPort.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 )  = aimc.thermalAmbient.temperatureFriction.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.Friction$aimc$friction, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a$aimc$friction$heatPort, .Modelica.SIunits.Temperature type: Real
// 279: aimc.internalThermalPort.heatPortFriction.T:VARIABLE(flow=false min = 0.0 start = 288.15 unit = "K" nominal = 300.0 final = true )  = aimc.thermalAmbient.temperatureFriction.port.T  "Port temperature".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Interfaces.InductionMachines.ThermalPortAIMC$aimc$internalThermalPort, .Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a, .Modelica.SIunits.Temperature type: Real
// 280: aimc.statorCore.w:VARIABLE(unit = "rad/s" )  = aimc.statorCoreParameters.wRef  "Remagnetization angular velocity".asmaFlow, .Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage$aimc, .Modelica.Electrical.Machines.Losses.InductionMachines.Core$aimc$statorCore, .Modelica.SIunits.AngularVelocity type: Real
//
//
// Simple Shared Equations (0, 0)
// ========================================
//
//
// Initial Equations (0, 0)
// ========================================
//
//
// Zero Crossings (3)
// ========================================
// time < sinevoltage1.sineVoltage[3].signalSource.startTime with index = 0 in equations [24]
// time < sinevoltage1.sineVoltage[2].signalSource.startTime with index = 1 in equations [25]
// time < sinevoltage1.sineVoltage[1].signalSource.startTime with index = 2 in equations [26]
//
//
// Relations (3)
// ========================================
// time < sinevoltage1.sineVoltage[3].signalSource.startTime with index = 0 in equations [24]
// time < sinevoltage1.sineVoltage[2].signalSource.startTime with index = 1 in equations [25]
// time < sinevoltage1.sineVoltage[1].signalSource.startTime with index = 2 in equations [26]
//
//
// Time Events (0)
// ========================================
//
//
// Constraints (0)
// ========================================
//
//
// Base partitions (0)
// ========================================
//
//
// Sub partitions (0)
// ========================================
//
//
// record SimulationResult
//     resultFile = "asmaFlow_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 20.0, numberOfIntervals = 10000, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'asmaFlow', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = ""
// end SimulationResult;
// "[Modelica 3.2.1/Electrical/Machines.mo:15348:7-15350:33:writable] Warning: Parameter terminalBox.terminalConnection has no value, and is fixed during initialization (fixed=true), using available start value (start="Y") as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:12918:7-12920:69:writable] Warning: Parameter aimc.TsOperational has no value, and is fixed during initialization (fixed=true), using available start value (start=293.15) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:12924:7-12926:71:writable] Warning: Parameter aimc.TsRef has no value, and is fixed during initialization (fixed=true), using available start value (start=293.15) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:12927:7-12929:71:writable] Warning: Parameter aimc.alpha20s has no value, and is fixed during initialization (fixed=true), using available start value (start=0.0) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:12803:7-12804:76:writable] Warning: Parameter aimc.Js has no value, and is fixed during initialization (fixed=true), using available start value (start=aimc.Jr) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:10964:7-10965:79:writable] Warning: Parameter aimc.statorCoreParameters.VRef has no value, and is fixed during initialization (fixed=true), using available start value (start=100.0) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:10940:7-10941:52:writable] Warning: Parameter aimc.strayLoadParameters.IRef has no value, and is fixed during initialization (fixed=true), using available start value (start=100.0) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:4740:9-4742:73:writable] Warning: Parameter aimc.TrRef has no value, and is fixed during initialization (fixed=true), using available start value (start=293.15) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:4743:9-4745:73:writable] Warning: Parameter aimc.alpha20r has no value, and is fixed during initialization (fixed=true), using available start value (start=0.0) as default value.
// [Modelica 3.2.1/Electrical/Machines.mo:4746:9-4748:76:writable] Warning: Parameter aimc.TrOperational has no value, and is fixed during initialization (fixed=true), using available start value (start=293.15) as default value.
// Warning: The initial conditions are not fully specified. Use +d=initialization for more information.
// "
// -15.0
// -15.0
// endResult
